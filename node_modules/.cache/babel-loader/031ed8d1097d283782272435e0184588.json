{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\n\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n\n  return getter ? getter.call(obj) : member.get(obj);\n};\n\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\n\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n\n  return method;\n};\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n}; // src/search/constants.ts\n\n\nvar SEARCH_URL = `https://api.mapbox.com/search/v1`;\nvar ENDPOINT_SUGGEST = \"suggest\";\nvar ENDPOINT_RETRIEVE = \"retrieve\";\nvar ENDPOINT_FORWARD = \"forward\";\nvar ENDPOINT_REVERSE = \"reverse\";\nvar SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nvar RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\nvar FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nvar PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\nvar REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nvar PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`; // src/LngLat.ts\n\nvar LngLat = class {\n  constructor(lng, lat) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n\n    this.lng = +lng;\n    this.lat = +lat;\n\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\"Invalid LngLat longitude value: must be between -180 and 180\");\n    }\n  }\n\n  toArray() {\n    return [this.lng, this.lat];\n  }\n\n  toString() {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  static convert(input) {\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (!Array.isArray(input) && typeof input == \"object\" && input !== null && (\"lng\" in input || \"lon\" in input) && \"lat\" in input) {\n      return new LngLat(Number(\"lng\" in input ? input.lng : input.lon), Number(input.lat));\n    }\n\n    throw new Error(\"`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n  }\n\n}; // src/LngLatBounds.ts\n\nvar LngLatBounds = class {\n  constructor(sw, ne) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  getSouthWest() {\n    return this._sw;\n  }\n\n  getNorthEast() {\n    return this._ne;\n  }\n\n  getNorthWest() {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  getSouthEast() {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  getWest() {\n    return this._sw.lng;\n  }\n\n  getSouth() {\n    return this._sw.lat;\n  }\n\n  getEast() {\n    return this._ne.lng;\n  }\n\n  getNorth() {\n    return this._ne.lat;\n  }\n\n  toArray() {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  toFlatArray() {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  toString() {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  static convert(input) {\n    if (!input) {\n      throw new Error(\"Invalid LngLatBounds convert value: falsy\");\n    }\n\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));\n    }\n\n    throw new Error(\"`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]\");\n  }\n\n}; // src/utils/uuid.ts\n\nfunction generateUUID() {\n  const randomString = Math.random().toString(16) + Date.now().toString(16) + Math.random().toString(16);\n  const uuidString = randomString.replace(/\\./g, \"\");\n  const uuid = [uuidString.slice(0, 8), uuidString.slice(8, 12), \"4\" + uuidString.slice(12, 15) + \"-8\" + uuidString.slice(15, 18), uuidString.slice(18, 30)].join(\"-\");\n  return uuid;\n} // src/SessionToken.ts\n\n\nvar SessionToken = class {\n  constructor(id) {\n    this.id = id != null ? id : generateUUID();\n  }\n\n  toString() {\n    return this.id;\n  }\n\n  static convert(token) {\n    return new SessionToken(token instanceof SessionToken ? token.id : token.toString());\n  }\n\n}; // src/MapboxError.ts\n\nvar UNKNOWN_ERROR = \"Unknown error\";\nvar MapboxError = class extends Error {\n  constructor(json, statusCode) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = \"MapboxError\";\n    this.statusCode = statusCode;\n  }\n\n  toString() {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n\n};\n\nfunction handleNonOkRes(res) {\n  return __async(this, null, function* () {\n    if (!res.ok) {\n      const json = yield res.json();\n      throw new MapboxError(json, res.status);\n    }\n  });\n} // src/fetch.ts\n\n\nvar _fetchImpl = globalThis.fetch;\nvar _abortControllerImpl = globalThis.AbortController;\n\nfunction polyfillFetch(_ref) {\n  let {\n    fetch,\n    AbortController\n  } = _ref;\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!fetch) {\n    throw new Error(\"Fetch implementation must include implementations of `fetch`.\");\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\nfunction getFetch() {\n  if (!_fetchImpl) {\n    throw new Error(\"Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.\");\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n} // src/utils/queryParams.ts\n\n\nfunction queryParams() {\n  const params = [];\n\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  for (const obj of objects) {\n    if (!obj) continue;\n    const entries = Object.entries(obj);\n\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join(\"&\");\n} // src/search/MapboxSearch.ts\n\n\nvar _getQueryParams, getQueryParams_fn, _getFetchInfo, getFetchInfo_fn;\n\nvar _MapboxSearch = class {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    __privateAdd(this, _getQueryParams);\n\n    __privateAdd(this, _getFetchInfo);\n\n    const _a = options,\n          {\n      accessToken\n    } = _a,\n          defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxSearch.defaults), defaults);\n  }\n\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      const {\n        sessionToken,\n        signal\n      } = optionsArg;\n\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n\n      if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n        throw new Error(\"to provide eta estimate: eta, navigation_profile, and origin are required\");\n      }\n\n      if (options.origin && !options.navigation_profile) {\n        throw new Error(\"to provide distance estimate: both navigation_profile and origin are required\");\n      }\n\n      const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n\n      const {\n        sessionToken: sessionTokenLike,\n        signal\n      } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(RETRIEVE_URL);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), __spreadProps(__spreadValues({}, __privateMethod(this, _getFetchInfo, getFetchInfo_fn).call(this, suggestion)), {\n        signal\n      }));\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n\n    if (!action) {\n      return false;\n    }\n\n    return action.method === \"POST\" && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  canSuggest(suggestion) {\n    const action = suggestion.action;\n\n    if (!action) {\n      return false;\n    }\n\n    return action.method === \"POST\" && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  forward(_0) {\n    return __async(this, arguments, function* (searchText) {\n      let optionsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n\n      const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  reverse(_0) {\n    return __async(this, arguments, function* (lngLat) {\n      let optionsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n\n      const searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n      const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      }, options.types && {\n        types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n      });\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n};\n\nvar MapboxSearch = _MapboxSearch;\n_getQueryParams = new WeakSet();\n\ngetQueryParams_fn = function (options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    navigation_profile: options.navigation_profile,\n    eta_type: options.eta_type\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.origin && {\n    origin: typeof options.origin === \"string\" ? options.origin : LngLat.convert(options.origin).toArray().join(\",\")\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\n\n_getFetchInfo = new WeakSet();\n\ngetFetchInfo_fn = function (suggestion) {\n  if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n    throw new Error(\"Suggestion cannot be retrieved or suggested\");\n  }\n\n  const action = suggestion.action;\n  const body = JSON.stringify(action.body);\n  return {\n    method: action.method,\n    body,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Content-Length\": body.length.toString()\n    }\n  };\n};\n\nMapboxSearch.defaults = {\n  language: \"en\"\n}; // src/autofill/constants.ts\n\nvar SEARCH_URL2 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_SUGGEST2 = \"suggest\";\nvar ENDPOINT_RETRIEVE2 = \"retrieve\";\nvar SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;\nvar RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`; // src/autofill/MapboxAutofill.ts\n\nvar _getQueryParams2, getQueryParams_fn2;\n\nvar _MapboxAutofill = class {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    __privateAdd(this, _getQueryParams2);\n\n    const _a = options,\n          {\n      accessToken\n    } = _a,\n          defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxAutofill.defaults), defaults);\n  }\n\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      const {\n        sessionToken,\n        signal\n      } = optionsArg;\n\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n\n      const url = new URL(`${SUGGEST_URL2}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return __spreadProps(__spreadValues({}, json), {\n        suggestions: json.suggestions.map(suggestion => {\n          return __spreadProps(__spreadValues({}, suggestion), {\n            original_search_text: searchText\n          });\n        })\n      });\n    });\n  }\n\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n\n      const {\n        sessionToken: sessionTokenLike,\n        signal\n      } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(`${RETRIEVE_URL2}/${suggestion.action.id}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n    return typeof (action == null ? void 0 : action.id) === \"string\";\n  }\n\n};\n\nvar MapboxAutofill = _MapboxAutofill;\n_getQueryParams2 = new WeakSet();\n\ngetQueryParams_fn2 = function (options) {\n  return queryParams({\n    types: \"address\",\n    streets: true,\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\n\nMapboxAutofill.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n}; // src/validate/constants.ts\n\nvar SEARCH_URL3 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_VALIDATE = \"retrieve\";\nvar VALIDATE_URL = `${SEARCH_URL3}/${ENDPOINT_VALIDATE}`; // src/validate/MapboxValidate.ts\n\nvar _getQueryParams3, getQueryParams_fn3;\n\nvar _MapboxValidate = class {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    __privateAdd(this, _getQueryParams3);\n\n    const _a = options,\n          {\n      accessToken\n    } = _a,\n          defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxValidate.defaults), defaults);\n  }\n\n  validate(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      const {\n        sessionToken,\n        signal\n      } = optionsArg;\n\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n\n      const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams3, getQueryParams_fn3).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n\n      if (json.features.length > 0) {\n        json.features = [json.features[0]];\n      }\n\n      return json;\n    });\n  }\n\n};\n\nvar MapboxValidate = _MapboxValidate;\n_getQueryParams3 = new WeakSet();\n\ngetQueryParams_fn3 = function (options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\n\nMapboxValidate.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n}; // src/geocode/constants.ts\n\nvar SEARCH_URL4 = `https://api.mapbox.com/geocoding/v5`;\nvar TEMP_URL = `${SEARCH_URL4}/mapbox.places`;\nvar PERMANENT_URL = `${SEARCH_URL4}/mapbox.places-permanent`; // src/geocode/MapboxGeocode.ts\n\nvar _getQueryParams4, getQueryParams_fn4;\n\nvar MapboxGeocode = class {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    __privateAdd(this, _getQueryParams4);\n\n    const _a = options,\n          {\n      accessToken\n    } = _a,\n          defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues({}, defaults);\n  }\n\n  forward(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      let signal;\n\n      if (optionsArg) {\n        ({\n          signal\n        } = optionsArg);\n      }\n\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n\n      const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n      url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const fetchInit = signal ? {\n        signal\n      } : {};\n      const res = yield fetch(url.toString(), fetchInit);\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  reverse(lngLat, optionsArg) {\n    return __async(this, null, function* () {\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n\n      let signal;\n\n      if (optionsArg) {\n        ({\n          signal\n        } = optionsArg);\n      }\n\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n\n      const searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n      const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n      url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options, true);\n      const {\n        fetch\n      } = getFetch();\n      const fetchInit = signal ? {\n        signal\n      } : {};\n      const res = yield fetch(url.toString(), fetchInit);\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n};\n_getQueryParams4 = new WeakSet();\n\ngetQueryParams_fn4 = function (options) {\n  let isReverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (isReverse) {\n    [\"proximity\", \"autocomplete\", \"fuzzyMatch\", \"bbox\"].forEach(key => {\n      if (key in options) {\n        delete options[key];\n      }\n    });\n  }\n\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    autocomplete: options.autocomplete,\n    fuzzyMatch: options.fuzzyMatch,\n    routing: options.routing,\n    worldview: options.worldview\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n}; // src/types.ts\n\n\nvar MatchCodeConfidence = /* @__PURE__ */(MatchCodeConfidence2 => {\n  MatchCodeConfidence2[\"exact\"] = \"exact\";\n  MatchCodeConfidence2[\"high\"] = \"high\";\n  MatchCodeConfidence2[\"medium\"] = \"medium\";\n  MatchCodeConfidence2[\"low\"] = \"low\";\n  return MatchCodeConfidence2;\n})(MatchCodeConfidence || {}); // src/utils/Evented.ts\n\n\nvar _listeners;\n\nvar Evented = class {\n  constructor() {\n    __privateAdd(this, _listeners, {});\n  }\n\n  addEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire(type, arg0) {\n    const listenersArr = __privateGet(this, _listeners);\n\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n\n};\n_listeners = new WeakMap(); // src/utils/debounce.ts\n\nfunction debounce(func, wait, signalFn) {\n  let timeout = null;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n\n      if (signal == null ? void 0 : signal.aborted) {\n        return;\n      }\n\n      func(...args);\n    }, wait);\n  };\n} // src/SearchSession.ts\n\n\nfunction createAbortController() {\n  const {\n    AbortController\n  } = getFetch();\n  return new AbortController();\n}\n\nvar _suggestions, _abort, _suggestDebounce;\n\nvar SearchSession = class extends Evented {\n  constructor(search) {\n    var _this;\n\n    let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super();\n    _this = this;\n    this.sessionToken = new SessionToken();\n\n    __privateAdd(this, _suggestions, void 0);\n\n    __privateAdd(this, _abort, createAbortController());\n\n    __privateAdd(this, _suggestDebounce, void 0);\n\n    __privateSet(this, _suggestDebounce, debounce(function (_0) {\n      for (var _len3 = arguments.length, _1 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        _1[_key3 - 1] = arguments[_key3];\n      }\n\n      return __async(_this, [_0, ..._1], function* (searchText) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        __privateGet(this, _abort).abort();\n\n        __privateSet(this, _abort, createAbortController());\n\n        if (!searchText) {\n          __privateSet(this, _suggestions, null);\n\n          this.fire(\"suggest\", __privateGet(this, _suggestions));\n          return;\n        }\n\n        try {\n          const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({\n            sessionToken: this.sessionToken\n          }, options), {\n            signal: __privateGet(this, _abort).signal\n          }));\n\n          __privateSet(this, _suggestions, res);\n\n          this.fire(\"suggest\", res);\n        } catch (err) {\n          if (err.name === \"AbortError\") {\n            return;\n          }\n\n          this.fire(\"suggesterror\", err);\n        }\n      });\n    }, wait, () => __privateGet(this, _abort).signal));\n\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  get suggestions() {\n    return __privateGet(this, _suggestions);\n  }\n\n  suggest(searchText, options) {\n    __privateGet(this, _suggestDebounce).call(this, searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn;\n      let suggestErrorFn;\n\n      suggestFn = res => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        resolve(res);\n      };\n\n      suggestErrorFn = err => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener(\"suggest\", suggestFn);\n      this.addEventListener(\"suggesterror\", suggestErrorFn);\n    });\n  }\n\n  clear() {\n    this.suggest(\"\");\n  }\n\n  retrieve(suggestion, options) {\n    return __async(this, null, function* () {\n      const res = yield this.search.retrieve(suggestion, __spreadValues({\n        sessionToken: this.sessionToken\n      }, options));\n      this.fire(\"retrieve\", res);\n      return res;\n    });\n  }\n\n  canRetrieve(suggestion) {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  canSuggest(suggestion) {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  abort() {\n    __privateGet(this, _abort).abort();\n\n    __privateSet(this, _abort, createAbortController());\n  }\n\n};\n_suggestions = new WeakMap();\n_abort = new WeakMap();\n_suggestDebounce = new WeakMap(); // src/featureToSuggestion.ts\n\nfunction featureToSuggestion(feature) {\n  const {\n    properties\n  } = feature;\n  return __spreadValues({}, properties);\n}\n\nexport { Evented, LngLat, LngLatBounds, MapboxAutofill, MapboxError, MapboxGeocode, MapboxSearch, MapboxValidate, MatchCodeConfidence, SearchSession, SessionToken, debounce, featureToSuggestion, polyfillFetch };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,IAAMA,aAAa,kCAAnB;AAEA,IAAMC,mBAAmB,SAAzB;AACA,IAAMC,oBAAoB,UAA1B;AACA,IAAMC,mBAAmB,SAAzB;AACA,IAAMC,mBAAmB,SAAzB;AAEA,IAAMC,cAAc,GAAGL,cAAcC,kBAArC;AACA,IAAMK,eAAe,GAAGN,cAAcE,mBAAtC;AAEA,IAAMK,cAAc,GAAGP,cAAcG,kBAArC;AACA,IAAMK,wBAAwB,GAAGR,wBAAwBG,kBAAzD;AAEA,IAAMM,cAAc,GAAGT,cAAcI,kBAArC;AACA,IAAMM,wBAAwB,GAAGV,wBAAwBI,kBAAzD,C;;ACKA,mBAAa;EAclBO,YAAYC,GAAZ,EAAyBC,GAAzB,EAAsC;IACpC,IAAIC,MAAMF,GAAN,KAAcE,MAAMD,GAAN,CAAlB,EAA8B;MAC5B,MAAM,IAAIE,KAAJ,CAAU,2BAA2BH,QAAQC,MAA7C,CAAN;IAAmD;;IAErD,KAAKD,GAAL,GAAW,CAACA,GAAZ;IACA,KAAKC,GAAL,GAAW,CAACA,GAAZ;;IACA,IAAI,KAAKA,GAAL,GAAW,EAAX,IAAiB,KAAKA,GAAL,GAAW,GAAhC,EAAqC;MACnC,MAAM,IAAIE,KAAJ,CACJ,2DADI,CAAN;IACE;;IAGJ,IAAI,KAAKH,GAAL,GAAW,GAAX,IAAkB,KAAKA,GAAL,GAAW,IAAjC,EAAuC;MACrC,MAAM,IAAIG,KAAJ,CACJ,8DADI,CAAN;IACE;EAAA;;EAeNC,UAA4B;IAC1B,OAAO,CAAC,KAAKJ,GAAN,EAAW,KAAKC,GAAhB,CAAP;EAAuB;;EAazBI,WAAmB;IACjB,OAAO,UAAU,KAAKL,QAAQ,KAAKC,MAAnC;EAAmC;;EAkB9B,eACLK,KADK,EAMG;IAER,IAAIA,iBAAiBC,MAArB,EAA6B;MAC3B,OAAO,IAAIA,MAAJ,CAAWD,MAAMN,GAAjB,EAAsBM,MAAML,GAA5B,CAAP;IAAmC;;IAGrC,IAAIO,MAAMC,OAAN,CAAcH,KAAd,KAAwBA,MAAMI,MAAN,KAAiB,CAA7C,EAAgD;MAC9C,OAAO,IAAIH,MAAJ,CAAWI,OAAOL,MAAM,CAAN,CAAP,CAAX,EAA6BK,OAAOL,MAAM,CAAN,CAAP,CAA7B,CAAP;IAAiD;;IAGnD,IACE,CAACE,MAAMC,OAAN,CAAcH,KAAd,CAAD,IACA,OAAOA,KAAP,IAAgB,QADhB,IAEAA,UAAU,IAFV,KAGC,SAASA,KAAT,IAAkB,SAASA,KAH5B,KAIA,SAASA,KALX,EAME;MACA,OAAO,IAAIC,MAAJ,CACLI,OAAO,SAASL,KAAT,GAAiBA,MAAMN,GAAvB,GAA6BM,MAAMM,GAA1C,CADK,EAELD,OAAOL,MAAML,GAAb,CAFK,CAAP;IAEe;;IAIjB,MAAM,IAAIE,KAAJ,CACJ,kJADI,CAAN;EACE;;AAzGc,CAAb,C;;ACPA,yBAAmB;EAcxBJ,YAAYc,EAAZ,EAA4BC,EAA5B,EAA4C;IAC1C,KAAKC,GAAL,GAAWR,OAAOS,OAAP,CAAeH,EAAf,CAAX;IACA,KAAKI,GAAL,GAAWV,OAAOS,OAAP,CAAeF,EAAf,CAAX;EAA0B;;EAa5BI,eAAuB;IACrB,OAAO,KAAKH,GAAZ;EAAY;;EAadI,eAAuB;IACrB,OAAO,KAAKF,GAAZ;EAAY;;EAcdG,eAAuB;IACrB,OAAO,IAAIb,MAAJ,CAAW,KAAKc,OAAL,EAAX,EAA2B,KAAKC,QAAL,EAA3B,CAAP;EAAuC;;EAczCC,eAAuB;IACrB,OAAO,IAAIhB,MAAJ,CAAW,KAAKiB,OAAL,EAAX,EAA2B,KAAKC,QAAL,EAA3B,CAAP;EAAuC;;EAazCJ,UAAkB;IAChB,OAAO,KAAKN,GAAL,CAASf,GAAhB;EAAgB;;EAalByB,WAAmB;IACjB,OAAO,KAAKV,GAAL,CAASd,GAAhB;EAAgB;;EAalBuB,UAAkB;IAChB,OAAO,KAAKP,GAAL,CAASjB,GAAhB;EAAgB;;EAalBsB,WAAmB;IACjB,OAAO,KAAKL,GAAL,CAAShB,GAAhB;EAAgB;;EAclBG,UAAgD;IAC9C,OAAO,CAAC,KAAKW,GAAL,CAASX,OAAT,EAAD,EAAqB,KAAKa,GAAL,CAASb,OAAT,EAArB,CAAP;EAAqC;;EAavCsB,cAAgD;IAC9C,OAAO,CAAC,KAAKX,GAAL,CAASf,GAAV,EAAe,KAAKe,GAAL,CAASd,GAAxB,EAA6B,KAAKgB,GAAL,CAASjB,GAAtC,EAA2C,KAAKiB,GAAL,CAAShB,GAApD,CAAP;EAA2D;;EAc7DI,WAAmB;IACjB,OAAO,gBAAgB,KAAKU,GAAL,CAASV,QAAT,EAAS,KAAe,KAAKY,GAAL,CAASZ,QAAT,EAAS,GAAxD;EAAwD;;EAmBnD,eACLC,KADK,EAKS;IACd,IAAI,CAACA,KAAL,EAAY;MACV,MAAM,IAAIH,KAAJ,CAAU,2CAAV,CAAN;IAAgB;;IAIlB,IAAIG,iBAAiBqB,YAArB,EAAmC;MACjC,OAAO,IAAIA,YAAJ,CAAiBrB,MAAMY,YAAN,EAAjB,EAAuCZ,MAAMa,YAAN,EAAvC,CAAP;IAAoD;;IAGtD,IAAIX,MAAMC,OAAN,CAAcH,KAAd,KAAwBA,MAAMI,MAAN,KAAiB,CAA7C,EAAgD;MAC9C,OAAO,IAAIiB,YAAJ,CACLpB,OAAOS,OAAP,CAAeV,MAAM,CAAN,CAAf,CADK,EAELC,OAAOS,OAAP,CAAeV,MAAM,CAAN,CAAf,CAFK,CAAP;IAEuB;;IAIzB,IAAIE,MAAMC,OAAN,CAAcH,KAAd,KAAwBA,MAAMI,MAAN,KAAiB,CAA7C,EAAgD;MAC9C,OAAO,IAAIiB,YAAJ,CACLpB,OAAOS,OAAP,CAAe,CAACV,MAAM,CAAN,CAAD,EAAWA,MAAM,CAAN,CAAX,CAAf,CADK,EAELC,OAAOS,OAAP,CAAe,CAACV,MAAM,CAAN,CAAD,EAAWA,MAAM,CAAN,CAAX,CAAf,CAFK,CAAP;IAEkC;;IAIpC,MAAM,IAAIH,KAAJ,CACJ,uIADI,CAAN;EACE;;AA/NoB,CAAnB,C;;ACOA,wBAAgC;EACrC,MAAMyB,eACJC,KAAKC,MAAL,GAAczB,QAAd,CAAuB,EAAvB,IACA0B,KAAKC,GAAL,GAAW3B,QAAX,CAAoB,EAApB,CADA,GAEAwB,KAAKC,MAAL,GAAczB,QAAd,CAAuB,EAAvB,CAHF;EAKA,MAAM4B,aAAaL,aAAaM,OAAb,CAAqB,KAArB,EAA4B,EAA5B,CAAnB;EAEA,MAAMC,OAAO,CACXF,WAAWG,KAAX,CAAiB,CAAjB,EAAoB,CAApB,CADW,EAEXH,WAAWG,KAAX,CAAiB,CAAjB,EAAoB,EAApB,CAFW,EAGX,MAAMH,WAAWG,KAAX,CAAiB,EAAjB,EAAqB,EAArB,CAAN,GAAiC,IAAjC,GAAwCH,WAAWG,KAAX,CAAiB,EAAjB,EAAqB,EAArB,CAH7B,EAIXH,WAAWG,KAAX,CAAiB,EAAjB,EAAqB,EAArB,CAJW,EAKXC,IALW,CAKN,GALM,CAAb;EAOA,OAAOF,IAAP;AAAO,C;;;ACXF,yBAAmB;EAMxBpC,YAAYuC,EAAZ,EAAyB;IACvB,KAAKA,EAAL,GAAUA,kBAAMC,cAAhB;EAAgB;;EAQlBlC,WAAmB;IACjB,OAAO,KAAKiC,EAAZ;EAAY;;EAQP,eAAQE,KAAR,EAAoD;IACzD,OAAO,IAAIC,YAAJ,CACLD,iBAAiBC,YAAjB,GAAgCD,MAAMF,EAAtC,GAA2CE,MAAMnC,QAAN,EADtC,CAAP;EACmD;;AA1B7B,CAAnB,C;;ACvBA,IAAMqC,gBAAgB,eAAtB;AASA,gCAA0BvC,KAA1B,CAAgC;EAGrCJ,YAAY4C,IAAZ,EAA2CC,UAA3C,EAA+D;IAC7D,MAAMC,OAAOF,KAAKG,OAAL,IAAgBH,KAAKI,KAArB,IAA8BL,aAArC,CAAN;IACA,KAAKM,IAAL,GAAY,aAAZ;IACA,KAAKJ,UAAL,GAAkBA,UAAlB;EAAkB;;EAMpBvC,WAAmB;IACjB,OAAO,GAAG,KAAK2C,SAAS,KAAKJ,gBAAgB,KAAKE,SAAlD;EAAkD;;AAbf,CAAhC;;AAuBP,wBAAqCG,GAArC,EAAmE;EAAA;IACjE,IAAI,CAACA,IAAIC,EAAT,EAAa;MACX,MAAMP,OAAO,MAAMM,IAAIN,IAAJ,EAAnB;MACA,MAAM,IAAIQ,WAAJ,CAAgBR,IAAhB,EAAsBM,IAAIG,MAA1B,CAAN;IAAgC;EAAA,CAH+B;AAG/B,C;;;AChCpC,IAAIC,aAA2BC,WAAWC,KAA1C;AACA,IAAIC,uBAA+CF,WAAWG,eAA9D;;AAsBO,6BAGC;EAAA,IAFN;IAAEF,KAAF;IAASE;EAAT,CAEM;EAAA,IADNC,KACM,uEADE,KACF;;EACN,IAAI,CAACH,KAAL,EAAY;IACV,MAAM,IAAIpD,KAAJ,CACJ,+DADI,CAAN;EACE;;EAIJ,IAAIkD,cAAc,CAACK,KAAnB,EAA0B;IACxB;EAAA;;EAEFL,aAAaE,KAAb;EACAC,uBAAuBC,eAAvB;AAAuB;;AAMlB,oBAAyC;EAC9C,IAAI,CAACJ,UAAL,EAAiB;IACf,MAAM,IAAIlD,KAAJ,CACJ,6JADI,CAAN;EACE;;EAIJ,OAAO;IACLoD,OAAOF,UADF;IAELI,iBAAiBD;EAFZ,CAAP;AAEmB,C;;;AC7Bd,uBAEG;EACR,MAAMG,SAAS,EAAf;;EADQ,kCADLC,OACK;IADLA,OACK;EAAA;;EAER,WAAWC,GAAX,IAAkBD,OAAlB,EAA2B;IACzB,IAAI,CAACC,GAAL,EAAU;IAEV,MAAMC,UAAUC,OAAOD,OAAP,CAAeD,GAAf,CAAhB;;IACA,WAAW,CAACG,GAAD,EAAMC,KAAN,CAAX,IAA2BH,OAA3B,EAAoC;MAClC,IAAIG,SAAS,IAAb,EAAmB;MACnBN,OAAOO,IAAP,CAAY,GAAGF,OAAOG,mBAAmBtB,OAAOoB,KAAP,CAAnB,CAA0B,EAAhD;IAAgD;EAAA;;EAIpD,OAAON,OAAOtB,IAAP,CAAY,GAAZ,CAAP;AAAmB,C;;;ACxCrB;;AAgNO,0BAAmB;EAkBxBtC,cAAiE;IAAA,IAArDqE,OAAqD,uEAAJ,EAAI;;IA0TjEC;;IA2CAA;;IApWE,MAAqCC,YAArC;IAAA,MAAQ;MAAAC;IAAA,IAA6BD,EAArC;IAAA,MAAwBE,qBAAaF,EAAb,GAAhB,aAAgB,EAAxB;;IAEA,KAAKC,WAAL,GAAmBA,WAAnB;IAGA,KAAKC,QAAL,GAAgBC,kCACXC,cAAaF,QADF,GAEXA,QAFW,CAAhB;EAEK;;EAyBDG,QACJC,UADI,EAEJC,UAFI,EAGyB;IAAA;MAC7B,IAAI,CAACD,UAAL,EAAiB;QACf,MAAM,IAAIzE,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAGlB,MAAM;QAAE2E,YAAF;QAAgBC;MAAhB,IAA2BF,UAAjC;;MAEA,MAAMT,UAAUY,gDACX,KAAKR,QADM,GAEXK,UAFW;QAGdC;MAHc,EAAhB;;MAMA,IAAIV,QAAQa,QAAR,KAAqB,CAACb,QAAQc,MAAT,IAAmB,CAACd,QAAQe,kBAAjD,CAAJ,EAA0E;QACxE,MAAM,IAAIhF,KAAJ,CACJ,2EADI,CAAN;MACE;;MAGJ,IAAIiE,QAAQc,MAAR,IAAkB,CAACd,QAAQe,kBAA/B,EAAmD;QACjD,MAAM,IAAIhF,KAAJ,CACJ,+EADI,CAAN;MACE;;MAIJ,MAAMiF,MAAM,IAAIC,GAAJ,CAAQ,GAAG5F,eAAe0E,mBAAmBS,UAAnB,CAAmB,EAA7C,CAAZ;MACAQ,IAAIE,MAAJ,GAAaC,sBAAKC,eAAL,EAAKC,iBAAL,aAAqBrB,OAArB,CAAb;MAEA,MAAM;QAAEb;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB;QACtC0E;MADsC,CAAtB,CAAlB;MAKA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CApCsB;EAoCtB;;EAkCHiD,SACJC,UADI,EAEJhB,UAFI,EAGuB;IAAA;MAC3B,IAAI,CAACgB,UAAL,EAAiB;QACf,MAAM,IAAI1F,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAElB,IAAI,CAAC,KAAK2F,WAAL,CAAiBD,UAAjB,CAAL,EAAmC;QACjC,MAAM,IAAI1F,KAAJ,CAAU,gCAAV,CAAN;MAAgB;;MAGlB,MAAM;QAAE2E,cAAciB,gBAAhB;QAAkChB;MAAlC,IAA6CF,UAAnD;MAEA,MAAMC,eAAerC,aAAazB,OAAb,CAAqB+E,gBAArB,CAArB;MAEA,MAAMX,MAAM,IAAIC,GAAJ,CAAQ3F,YAAR,CAAZ;MACA0F,IAAIE,MAAJ,GAAaU,YAAY;QACvBC,cAAc,KAAK1B,WADI;QAEvB2B,eAAepB,aAAaxC;MAFL,CAAZ,CAAb;MAKA,MAAM;QAAEiB;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB2E,iCACnCO,sBAAKY,aAAL,EAAKC,eAAL,aAAmBP,UAAnB,CADmC;QAEtCd;MAFsC,EAAtB,CAAlB;MAMA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CA5BoB;EA4BpB;;EAYTmD,YAAYD,UAAZ,EAA6C;IAC3C,MAAMQ,SAASR,WAAWQ,MAA1B;;IACA,IAAI,CAACA,MAAL,EAAa;MACX,OAAO,KAAP;IAAO;;IAGT,OAAOA,OAAOC,MAAP,KAAkB,MAAlB,IAA4BD,OAAOE,QAAP,KAAoBjH,iBAAvD;EAAuD;;EAYzDkH,WAAWX,UAAX,EAA4C;IAC1C,MAAMQ,SAASR,WAAWQ,MAA1B;;IACA,IAAI,CAACA,MAAL,EAAa;MACX,OAAO,KAAP;IAAO;;IAGT,OAAOA,OAAOC,MAAP,KAAkB,MAAlB,IAA4BD,OAAOE,QAAP,KAAoBlH,gBAAvD;EAAuD;;EAiCnDoH,QACJC,EADI,EAGuB;IAAA,2CAF3B9B,UAE2B;MAAA,IAD3BC,UAC2B,uEADsC,EACtC;;MAC3B,IAAI,CAACD,UAAL,EAAiB;QACf,MAAM,IAAIzE,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAGlB,MAAMiE,UAAUK,kCACX,KAAKD,QADM,GAEXK,UAFW,CAAhB;;MAKA,MAAM8B,UAAUvC,QAAQwC,SAAR,GAAoBhH,qBAApB,GAA4CD,WAA5D;MACA,MAAMyF,MAAM,IAAIC,GAAJ,CAAQ,GAAGsB,WAAWxC,mBAAmBS,UAAnB,CAAmB,EAAzC,CAAZ;MACAQ,IAAIE,MAAJ,GAAaC,sBAAKC,eAAL,EAAKC,iBAAL,aAAqBrB,OAArB,CAAb;MAEA,MAAM;QAAEb;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB;QACtC0E,QAAQX,QAAQW;MADsB,CAAtB,CAAlB;MAKA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CAvBoB;EAuBpB;;EAgCHkE,QACJH,EADI,EAGuB;IAAA,2CAF3BI,MAE2B;MAAA,IAD3BjC,UAC2B,uEADsC,EACtC;;MAC3B,IAAI,CAACiC,MAAL,EAAa;QACX,MAAM,IAAI3G,KAAJ,CAAU,oBAAV,CAAN;MAAgB;;MAGlB,MAAMiE,UAAUK,kCACX,KAAKD,QADM,GAEXK,UAFW,CAAhB;;MAKA,MAAMD,aACJ,OAAOkC,MAAP,KAAkB,QAAlB,GACIA,MADJ,GAEIvG,OAAOS,OAAP,CAAe8F,MAAf,EAAuB1G,OAAvB,GAAiCiC,IAAjC,CAAsC,GAAtC,CAHN;MAKA,MAAMsE,UAAUvC,QAAQwC,SAAR,GAAoB9G,qBAApB,GAA4CD,WAA5D;MACA,MAAMuF,MAAM,IAAIC,GAAJ,CAAQ,GAAGsB,WAAWxC,mBAAmBS,UAAnB,CAAmB,EAAzC,CAAZ;MACAQ,IAAIE,MAAJ,GAAaU,YACX;QACEC,cAAc,KAAK1B,WADrB;QAEEwC,UAAU3C,QAAQ2C,QAFpB;QAGEC,OAAO5C,QAAQ4C;MAHjB,CADW,EAMX5C,QAAQ6C,KAAR,IAAiB;QACfA,OACE,OAAO7C,QAAQ6C,KAAf,KAAyB,QAAzB,GACI7C,QAAQ6C,KADZ,GAEI,CAAC,GAAG7C,QAAQ6C,KAAZ,EAAmB5E,IAAnB,CAAwB,GAAxB;MAJS,CANN,CAAb;MAcA,MAAM;QAAEkB;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB;QACtC0E,QAAQX,QAAQW;MADsB,CAAtB,CAAlB;MAKA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CAxCoB;EAwCpB;;AArUe,CAAnB;;AAAA;AA4UL6C;;AAAAC,oBAAe,UAACrB,OAAD,EAA0D;EACvE,OAAO4B,YACL;IACEC,cAAc,KAAK1B,WADrB;IAEEwC,UAAU3C,QAAQ2C,QAFpB;IAGEG,SAAS9C,QAAQ8C,OAHnB;IAIEF,OAAO5C,QAAQ4C,KAJjB;IAKE7B,oBAAoBf,QAAQe,kBAL9B;IAMEF,UAAUb,QAAQa;EANpB,CADK,EASLb,QAAQU,YAAR,IAAwB;IACtBoB,eAAezD,aAAazB,OAAb,CAAqBoD,QAAQU,YAA7B,EAA2CxC;EADpC,CATnB,EAYL8B,QAAQc,MAAR,IAAkB;IAChBA,QACE,OAAOd,QAAQc,MAAf,KAA0B,QAA1B,GACId,QAAQc,MADZ,GAEI3E,OAAOS,OAAP,CAAeoD,QAAQc,MAAvB,EAA+B9E,OAA/B,GAAyCiC,IAAzC,CAA8C,GAA9C;EAJU,CAZb,EAkBL+B,QAAQ+C,SAAR,IAAqB;IACnBA,WACE,OAAO/C,QAAQ+C,SAAf,KAA6B,QAA7B,GACI/C,QAAQ+C,SADZ,GAEI5G,OAAOS,OAAP,CAAeoD,QAAQ+C,SAAvB,EAAkC/G,OAAlC,GAA4CiC,IAA5C,CAAiD,GAAjD;EAJa,CAlBhB,EAwBL+B,QAAQgD,IAAR,IAAgB;IACdA,MACE,OAAOhD,QAAQgD,IAAf,KAAwB,QAAxB,GACIhD,QAAQgD,IADZ,GAEIzF,aAAaX,OAAb,CAAqBoD,QAAQgD,IAA7B,EAAmC1F,WAAnC,GAAiDW,IAAjD,CAAsD,GAAtD;EAJQ,CAxBX,EA8BL+B,QAAQ6C,KAAR,IAAiB;IACfA,OACE,OAAO7C,QAAQ6C,KAAf,KAAyB,QAAzB,GACI7C,QAAQ6C,KADZ,GAEI,CAAC,GAAG7C,QAAQ6C,KAAZ,EAAmB5E,IAAnB,CAAwB,GAAxB;EAJS,CA9BZ,CAAP;AAkCkC,CAnCpC;;AA2CA8D;;AAAAC,kBAAa,UAACP,UAAD,EAA+C;EAC1D,IAAI,CAAC,KAAKC,WAAL,CAAiBD,UAAjB,CAAD,IAAiC,CAAC,KAAKW,UAAL,CAAgBX,UAAhB,CAAtC,EAAmE;IACjE,MAAM,IAAI1F,KAAJ,CAAU,6CAAV,CAAN;EAAgB;;EAGlB,MAAMkG,SAASR,WAAWQ,MAA1B;EACA,MAAMgB,OAAOC,KAAKC,SAAL,CAAelB,OAAOgB,IAAtB,CAAb;EAEA,OAAO;IACLf,QAAQD,OAAOC,MADV;IAELe,IAFK;IAGLG,SAAS;MACP,gBAAgB,kBADT;MAEP,kBAAkBH,KAAK3G,MAAL,CAAYL,QAAZ;IAFX;EAHJ,CAAP;AAKkC,CAbpC;;AAtXOoH,YADF,CACEjD,WAA6B;EAClCuC,UAAU;AADwB,CAA7B,C;;ACjNF,IAAMW,cAAa,oCAAnB;AAEA,IAAMC,oBAAmB,SAAzB;AACA,IAAMC,qBAAoB,UAA1B;AAEA,IAAMC,eAAc,GAAGH,eAAcC,mBAArC;AACA,IAAMG,gBAAe,GAAGJ,eAAcE,oBAAtC,C;;ACNP;;AAgIO,4BAAqB;EAmB1B7H,cAAyE;IAAA,IAA7DqE,OAA6D,uEAAJ,EAAI;;IAiIzEC;;IAhIE,MAAqCC,YAArC;IAAA,MAAQ;MAAAC;IAAA,IAA6BD,EAArC;IAAA,MAAwBE,qBAAaF,EAAb,GAAhB,aAAgB,EAAxB;;IAEA,KAAKC,WAAL,GAAmBA,WAAnB;IAGA,KAAKC,QAAL,GAAgBC,kCACXsD,gBAAevD,QADJ,GAEXA,QAFW,CAAhB;EAEK;;EAqBDG,QACJC,UADI,EAEJC,UAFI,EAGiC;IAAA;MACrC,IAAI,CAACD,UAAL,EAAiB;QACf,MAAM,IAAIzE,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAGlB,MAAM;QAAE2E,YAAF;QAAgBC;MAAhB,IAA2BF,UAAjC;;MAEA,MAAMT,UAAUY,gDACX,KAAKR,QADM,GAEXK,UAFW;QAGdC;MAHc,EAAhB;;MAMA,MAAMM,MAAM,IAAIC,GAAJ,CAAQ,GAAGwC,gBAAe1D,mBAAmBS,UAAnB,CAAmB,EAA7C,CAAZ;MACAQ,IAAIE,MAAJ,GAAaC,sBAAKyC,gBAAL,EAAKC,kBAAL,aAAqB7D,OAArB,CAAb;MAEA,MAAM;QAAEb;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB;QACtC0E;MADsC,CAAtB,CAAlB;MAKA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MAGA,OAAOqC,iCACFrC,IADE;QAELuF,aAAavF,KAAKuF,WAAL,CAAiBC,GAAjB,CAAsBtC,UAAD,IAAgB;UAChD,OAAOb,iCACFa,UADE;YAELuC,sBAAsBxD;UAFjB,EAAP;QAEwB,CAHb;MAFR,EAAP;IAK4B,CAhCS;EAgCT;;EA+BxBgB,SACJC,UADI,EAEJhB,UAFI,EAG+B;IAAA;MACnC,IAAI,CAACgB,UAAL,EAAiB;QACf,MAAM,IAAI1F,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAElB,IAAI,CAAC,KAAK2F,WAAL,CAAiBD,UAAjB,CAAL,EAAmC;QACjC,MAAM,IAAI1F,KAAJ,CAAU,gCAAV,CAAN;MAAgB;;MAGlB,MAAM;QAAE2E,cAAciB,gBAAhB;QAAkChB;MAAlC,IAA6CF,UAAnD;MAEA,MAAMC,eAAerC,aAAazB,OAAb,CAAqB+E,gBAArB,CAArB;MAEA,MAAMX,MAAM,IAAIC,GAAJ,CAAQ,GAAGyC,iBAAgBjC,WAAWQ,MAAX,CAAkB/D,IAA7C,CAAZ;MACA8C,IAAIE,MAAJ,GAAaU,YAAY;QACvBC,cAAc,KAAK1B,WADI;QAEvB2B,eAAepB,aAAaxC;MAFL,CAAZ,CAAb;MAKA,MAAM;QAAEiB;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB;QAAE0E;MAAF,CAAtB,CAAlB;MAGA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CAzB4B;EAyB5B;;EAwCTmD,YAAYD,UAAZ,EAAqD;IACnD,MAAMQ,SAASR,WAAWQ,MAA1B;IAEA,OAAO,QAAOA,iCAAQ/D,EAAf,MAAsB,QAA7B;EAA6B;;AAzLL,CAArB;;AAAA;AAoJL0F;;AAAAC,qBAAe,UACb7D,OADa,EAEL;EACR,OAAO4B,YACL;IACEiB,OAAO,SADT;IAEEoB,SAAS,IAFX;IAGEpC,cAAc,KAAK1B,WAHrB;IAIEwC,UAAU3C,QAAQ2C,QAJpB;IAKEG,SAAS9C,QAAQ8C,OALnB;IAMEF,OAAO5C,QAAQ4C;EANjB,CADK,EASL5C,QAAQU,YAAR,IAAwB;IACtBoB,eAAezD,aAAazB,OAAb,CAAqBoD,QAAQU,YAA7B,EAA2CxC;EADpC,CATnB,EAYL8B,QAAQ+C,SAAR,IAAqB;IACnBA,WACE,OAAO/C,QAAQ+C,SAAf,KAA6B,QAA7B,GACI/C,QAAQ+C,SADZ,GAEI5G,OAAOS,OAAP,CAAeoD,QAAQ+C,SAAvB,EAAkC/G,OAAlC,GAA4CiC,IAA5C,CAAiD,GAAjD;EAJa,CAZhB,EAkBL+B,QAAQgD,IAAR,IAAgB;IACdA,MACE,OAAOhD,QAAQgD,IAAf,KAAwB,QAAxB,GACIhD,QAAQgD,IADZ,GAEIzF,aAAaX,OAAb,CAAqBoD,QAAQgD,IAA7B,EAAmC1F,WAAnC,GAAiDW,IAAjD,CAAsD,GAAtD;EAJQ,CAlBX,CAAP;AAsBgE,CAzBlE;;AAnJOiG,cADF,CACE9D,WAAqC;EAC1CuC,UAAU,IADgC;EAE1CI,WAAW;AAF+B,CAArC,C;;ACjIF,IAAMoB,cAAa,oCAAnB;AAEA,IAAMC,oBAAoB,UAA1B;AAEA,IAAMC,eAAe,GAAGF,eAAcC,mBAAtC,C;;ACJP;;AAoGO,4BAAqB;EAmB1BzI,cAAyE;IAAA,IAA7DqE,OAA6D,uEAAJ,EAAI;;IA2EzEC;;IA1EE,MAAqCC,YAArC;IAAA,MAAQ;MAAAC;IAAA,IAA6BD,EAArC;IAAA,MAAwBE,qBAAaF,EAAb,GAAhB,aAAgB,EAAxB;;IAEA,KAAKC,WAAL,GAAmBA,WAAnB;IAGA,KAAKC,QAAL,GAAgBC,kCACXiE,gBAAelE,QADJ,GAEXA,QAFW,CAAhB;EAEK;;EA4BDmE,SACJ/D,UADI,EAEJC,UAFI,EAGuB;IAAA;MAC3B,IAAI,CAACD,UAAL,EAAiB;QACf,MAAM,IAAIzE,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAGlB,MAAM;QAAE2E,YAAF;QAAgBC;MAAhB,IAA2BF,UAAjC;;MAEA,MAAMT,UAAUY,gDACX,KAAKR,QADM,GAEXK,UAFW;QAGdC;MAHc,EAAhB;;MAMA,MAAMM,MAAM,IAAIC,GAAJ,CAAQ,GAAGoD,gBAAgBtE,mBAAmBS,UAAnB,CAAmB,EAA9C,CAAZ;MACAQ,IAAIE,MAAJ,GAAaC,sBAAKqD,gBAAL,EAAKC,kBAAL,aAAqBzE,OAArB,CAAb;MAEA,MAAM;QAAEb;MAAF,IAAYmC,UAAlB;MACA,MAAMzC,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsB;QACtC0E;MADsC,CAAtB,CAAlB;MAKA,MAAMY,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;;MAEA,IAAIA,KAAKmG,QAAL,CAAcpI,MAAd,GAAuB,CAA3B,EAA8B;QAC5BiC,KAAKmG,QAAL,GAAgB,CAACnG,KAAKmG,QAAL,CAAc,CAAd,CAAD,CAAhB;MAA+B;;MAGjC,OAAOnG,IAAP;IAAO,CA9BoB;EA8BpB;;AAxFiB,CAArB;;AAAA;AA8FLiG;;AAAAC,qBAAe,UACbzE,OADa,EAEL;EACR,OAAO4B,YACL;IACEC,cAAc,KAAK1B,WADrB;IAEEwC,UAAU3C,QAAQ2C,QAFpB;IAGEG,SAAS9C,QAAQ8C;EAHnB,CADK,EAML9C,QAAQU,YAAR,IAAwB;IACtBoB,eAAezD,aAAazB,OAAb,CAAqBoD,QAAQU,YAA7B,EAA2CxC;EADpC,CANnB,EASL8B,QAAQ+C,SAAR,IAAqB;IACnBA,WACE,OAAO/C,QAAQ+C,SAAf,KAA6B,QAA7B,GACI/C,QAAQ+C,SADZ,GAEI5G,OAAOS,OAAP,CAAeoD,QAAQ+C,SAAvB,EAAkC/G,OAAlC,GAA4CiC,IAA5C,CAAiD,GAAjD;EAJa,CAThB,EAeL+B,QAAQgD,IAAR,IAAgB;IACdA,MACE,OAAOhD,QAAQgD,IAAf,KAAwB,QAAxB,GACIhD,QAAQgD,IADZ,GAEIzF,aAAaX,OAAb,CAAqBoD,QAAQgD,IAA7B,EAAmC1F,WAAnC,GAAiDW,IAAjD,CAAsD,GAAtD;EAJQ,CAfX,CAAP;AAmBgE,CAtBlE;;AA7FO0G,cADF,CACEvE,WAAqC;EAC1CuC,UAAU,IADgC;EAE1CI,WAAW;AAF+B,CAArC,C;;ACrGF,IAAM6B,cAAa,qCAAnB;AAEA,IAAMC,WAAW,GAAGD,2BAApB;AACA,IAAME,gBAAgB,GAAGF,qCAAzB,C;;ACHP;;AAoJO,0BAAoB;EAazBjJ,cAAwE;IAAA,IAA5DqE,OAA4D,uEAAJ,EAAI;;IAwJxEC;;IAvJE,MAAqCC,YAArC;IAAA,MAAQ;MAAAC;IAAA,IAA6BD,EAArC;IAAA,MAAwBE,qBAAaF,EAAb,GAAhB,aAAgB,EAAxB;;IAEA,KAAKC,WAAL,GAAmBA,WAAnB;IAGA,KAAKC,QAAL,GAAgBC,mBACXD,QADW,CAAhB;EACK;;EAuCDiC,QACJ7B,UADI,EAEJC,UAFI,EAGsB;IAAA;MAC1B,IAAI,CAACD,UAAL,EAAiB;QACf,MAAM,IAAIzE,KAAJ,CAAU,wBAAV,CAAN;MAAgB;;MAGlB,IAAI4E,MAAJ;;MACA,IAAIF,UAAJ,EAAgB;QACb;UAAEE;QAAF,IAAaF,UAAb;MAAa;;MAGhB,MAAMT,UAAUK,kCACX,KAAKD,QADM,GAEXK,UAFW,CAAhB;;MAKA,MAAM8B,UAAUvC,QAAQwC,SAAR,GAAoBsC,aAApB,GAAoCD,QAApD;MACA,MAAM7D,MAAM,IAAIC,GAAJ,CAAQ,GAAGsB,WAAWxC,mBAAmBS,UAAnB,CAAmB,OAAzC,CAAZ;MACAQ,IAAIE,MAAJ,GAAaC,sBAAK4D,gBAAL,EAAKC,kBAAL,aAAqBhF,OAArB,CAAb;MAEA,MAAM;QAAEb;MAAF,IAAYmC,UAAlB;MACA,MAAM2D,YAAYtE,SAAS;QAAEA;MAAF,CAAT,GAAsB,EAAxC;MACA,MAAM9B,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsBgJ,SAAtB,CAAlB;MAGA,MAAM1D,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CA3BmB;EA2BnB;;EAoCHkE,QACJC,MADI,EAEJjC,UAFI,EAGsB;IAAA;MAC1B,IAAI,CAACiC,MAAL,EAAa;QACX,MAAM,IAAI3G,KAAJ,CAAU,oBAAV,CAAN;MAAgB;;MAGlB,IAAI4E,MAAJ;;MACA,IAAIF,UAAJ,EAAgB;QACb;UAAEE;QAAF,IAAaF,UAAb;MAAa;;MAGhB,MAAMT,UAAUK,kCACX,KAAKD,QADM,GAEXK,UAFW,CAAhB;;MAKA,MAAMD,aACJ,OAAOkC,MAAP,KAAkB,QAAlB,GACIA,MADJ,GAEIvG,OAAOS,OAAP,CAAe8F,MAAf,EAAuB1G,OAAvB,GAAiCiC,IAAjC,CAAsC,GAAtC,CAHN;MAIA,MAAMsE,UAAUvC,QAAQwC,SAAR,GAAoBsC,aAApB,GAAoCD,QAApD;MACA,MAAM7D,MAAM,IAAIC,GAAJ,CAAQ,GAAGsB,WAAWxC,mBAAmBS,UAAnB,CAAmB,OAAzC,CAAZ;MACAQ,IAAIE,MAAJ,GAAaC,sBAAK4D,gBAAL,EAAKC,kBAAL,aAAqBhF,OAArB,EAA8B,IAA9B,CAAb;MAEA,MAAM;QAAEb;MAAF,IAAYmC,UAAlB;MACA,MAAM2D,YAAYtE,SAAS;QAAEA;MAAF,CAAT,GAAsB,EAAxC;MACA,MAAM9B,MAAM,MAAMM,MAAM6B,IAAI/E,QAAJ,EAAN,EAAsBgJ,SAAtB,CAAlB;MAGA,MAAM1D,eAAe1C,GAAf,CAAN;MAEA,MAAMN,OAAQ,MAAMM,IAAIN,IAAJ,EAApB;MACA,OAAOA,IAAP;IAAO,CA/BmB;EA+BnB;;AA/JgB,CAApB;AAqKLwG;;AAAAC,qBAAe,UAAChF,OAAD,EAA8D;EAAA,IAA3BkF,SAA2B,uEAAf,KAAe;;EAE3E,IAAIA,SAAJ,EAAe;IACb,CAAC,WAAD,EAAc,cAAd,EAA8B,YAA9B,EAA4C,MAA5C,EAAoDC,OAApD,CAA6DvF,GAAD,IAAS;MACnE,IAAIA,OAAOI,OAAX,EAAoB;QAClB,OAAOA,QAAQJ,GAAR,CAAP;MAAe;IAAA,CAFnB;EAEmB;;EAIrB,OAAOgC,YACL;IACEC,cAAc,KAAK1B,WADrB;IAEEwC,UAAU3C,QAAQ2C,QAFpB;IAGEG,SAAS9C,QAAQ8C,OAHnB;IAIEF,OAAO5C,QAAQ4C,KAJjB;IAKEwC,cAAcpF,QAAQoF,YALxB;IAMEC,YAAYrF,QAAQqF,UANtB;IAOEC,SAAStF,QAAQsF,OAPnB;IAQEC,WAAWvF,QAAQuF;EARrB,CADK,EAWLvF,QAAQ+C,SAAR,IAAqB;IACnBA,WACE,OAAO/C,QAAQ+C,SAAf,KAA6B,QAA7B,GACI/C,QAAQ+C,SADZ,GAEI5G,OAAOS,OAAP,CAAeoD,QAAQ+C,SAAvB,EAAkC/G,OAAlC,GAA4CiC,IAA5C,CAAiD,GAAjD;EAJa,CAXhB,EAiBL+B,QAAQgD,IAAR,IAAgB;IACdA,MACE,OAAOhD,QAAQgD,IAAf,KAAwB,QAAxB,GACIhD,QAAQgD,IADZ,GAEIzF,aAAaX,OAAb,CAAqBoD,QAAQgD,IAA7B,EAAmC1F,WAAnC,GAAiDW,IAAjD,CAAsD,GAAtD;EAJQ,CAjBX,EAuBL+B,QAAQ6C,KAAR,IAAiB;IACfA,OACE,OAAO7C,QAAQ6C,KAAf,KAAyB,QAAzB,GACI7C,QAAQ6C,KADZ,GAEI,CAAC,GAAG7C,QAAQ6C,KAAZ,EAAmB5E,IAAnB,CAAwB,GAAxB;EAJS,CAvBZ,CAAP;AA2BkC,CApCpC,C;;;ACtTK,IAAWuH,sBAAX,gBAAWC,oBAAX;EAILA,gCAAQ,OAAR;EAIAA,+BAAO,MAAP;EAIAA,iCAAS,QAAT;EAIAA,8BAAM,KAAN;EAhBgB;AAAA,CAAX,EAAWD,yBAAX,E;;;ACHP;;AAWO,oBAAiB;EAAjB7J,cAXP;IAYEsE,+BAEK,EAFL;EAEK;;EAQLyF,iBACEC,IADF,EAEEC,QAFF,EAGQ;IACN,MAAMC,eAAeC,mBAAKC,UAAL,CAArB;;IAGA,IAAI,CAACF,aAAaF,IAAb,CAAL,EAAyB;MACvBE,aAAaF,IAAb,IAAqB,EAArB;IAAqB;;IAGvBE,aAAaF,IAAb,EAAmB7F,IAAnB,CAAwB8F,QAAxB;EAAwB;;EAS1BI,oBACEL,IADF,EAEEC,QAFF,EAGQ;IACN,MAAMC,eAAeC,mBAAKC,UAAL,CAArB;;IAGA,IAAI,CAACF,aAAaF,IAAb,CAAL,EAAyB;MACvB;IAAA;;IAGF,MAAMM,YAAYJ,aAAaF,IAAb,CAAlB;IACA,MAAMO,QAAQD,UAAUE,OAAV,CAAkBP,QAAlB,CAAd;;IACA,IAAIM,UAAU,EAAd,EAAkB;MAChBD,UAAUG,MAAV,CAAiBF,KAAjB,EAAwB,CAAxB;IAAwB;EAAA;;EAI5BG,KAAwBV,IAAxB,EAAiCW,IAAjC,EAAmD;IACjD,MAAMT,eAAeC,mBAAKC,UAAL,CAArB;;IAGA,IAAI,CAACF,aAAaF,IAAb,CAAL,EAAyB;MACvB;IAAA;;IAGF,MAAMM,YAAYJ,aAAaF,IAAb,CAAlB;;IACA,WAAWC,QAAX,IAAuBK,SAAvB,EAAkC;MAChCL,SAASU,IAAT;IAAS;EAAA;;AA3DS,CAAjB;AACLP,2B;;ACRK,kBACLQ,IADK,EAELC,IAFK,EAGLC,QAHK,EAIF;EACH,IAAIC,UAAU,IAAd;EAEA,OAAQ,YAA4B;IAAA,mCAAxBC,IAAwB;MAAxBA,IAAwB;IAAA;;IAClC,IAAID,YAAY,IAAhB,EAAsB;MACpBE,aAAaF,OAAb;IAAa;;IAGf,MAAM/F,SAAS8F,YAAYA,UAA3B;IACAC,UAAUG,WAAW,MAAM;MACzBH,UAAU,IAAV;;MACA,IAAI/F,iCAAQmG,OAAZ,EAAqB;QACnB;MAAA;;MAEFP,KAAK,GAAGI,IAAR;IAAQ,CALA,EAMPH,IANO,CAAV;EAMG,CAZL;AAYK,C;;;ACZP,iCAAkD;EAChD,MAAM;IAAEnH;EAAF,IAAsBiC,UAA5B;EACA,OAAO,IAAIjC,eAAJ,EAAP;AAAW;;AAbb;;AAoHO,kCAKG0H,OALH,CAK6D;EAgClEpL,YACEuF,MADF,EAQE;IAAA;;IAAA,IADAsF,IACA,uEADO,CACP;IACA,OADA;IAAA;IAnBF,oBAAe,IAAInI,YAAJ,EAAf;;IAEA4B;;IAiFAA,2BAAS+G,uBAAT;;IAEA/G;;IA9DEgH,mBAAKC,gBAAL,EAAwBC,SACtB,UACE7E,EADF;MAAA,mCAGoB8E,EAHpB;QAGoBA,EAHpB;MAAA;;MAAA,OAGoBC,gBAFlB/E,EAEkB,qBAFlB9B,UAEkB;QAAA,IADlBR,OACkB,uEADU,EACV;;QAElB8F,mBAAKwB,MAAL,EAAYC,KAAZ;;QACAN,mBAAKK,MAAL,EAAcN,uBAAd;;QAEA,IAAI,CAACxG,UAAL,EAAiB;UACfyG,mBAAKO,YAAL,EAAoB,IAApB;;UACA,KAAKnB,IAAL,CAAU,SAAV,EAAqBP,mBAAK0B,YAAL,CAArB;UACA;QAAA;;QAGF,IAAI;UACF,MAAM3I,MAAM,MAAM,KAAKqC,MAAL,CAAYX,OAAZ,CAAoBC,UAApB,EAAgCI;YAChDF,cAAc,KAAKA;UAD6B,GAE7CV,OAF6C;YAGhDW,QAAQmF,mBAAKwB,MAAL,EAAY3G;UAH4B,EAAhC,CAAlB;;UAMAsG,mBAAKO,YAAL,EAAoB3I,GAApB;;UACA,KAAKwH,IAAL,CAAU,SAAV,EAAqBxH,GAArB;QAAqB,CARvB,CAQuB,OACd4I,GADc,EACrB;UACA,IAAIA,IAAI7I,IAAJ,KAAa,YAAjB,EAA+B;YAC7B;UAAA;;UAGF,KAAKyH,IAAL,CAAU,cAAV,EAA0BoB,GAA1B;QAA0B;MAAA,CAzBV,CAHpB;IAAA,CADsB,EAgCtBjB,IAhCsB,EAiCtB,MAAMV,mBAAKwB,MAAL,EAAY3G,MAjCI,CAAxB;;IAwCAhB,OAAO+H,gBAAP,CAAwB,IAAxB,EAA8B;MAC5BxG,QAAQ;QACNrB,OAAOqB,MADD;QAENyG,UAAU;MAFJ,CADoB;MAK5BR,UAAU;QACRtH,OAAO2G,IADC;QAERmB,UAAU;MAFF;IALkB,CAA9B;EAOc;;EA/DZ,kBAAyC;IAC3C,OAAO7B,mBAAK0B,YAAL,CAAP;EAAY;;EAwGdjH,QACEC,UADF,EAEER,OAFF,EAG+B;IAC7B8F,mBAAKoB,gBAAL,aAAsB1G,UAAtB,EAAkCR,OAAlC;;IAEA,OAAO,IAAI4H,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;MACtC,IAAIC,SAAJ;MACA,IAAIC,cAAJ;;MAEAD,YAAalJ,GAAD,IAAS;QACnB,KAAKmH,mBAAL,CAAyB,SAAzB,EAAoC+B,SAApC;QACA,KAAK/B,mBAAL,CAAyB,cAAzB,EAAyCgC,cAAzC;QACAH,QAAQhJ,GAAR;MAAQ,CAHV;;MAKAmJ,iBAAkBP,GAAD,IAAS;QACxB,KAAKzB,mBAAL,CAAyB,SAAzB,EAAoC+B,SAApC;QACA,KAAK/B,mBAAL,CAAyB,cAAzB,EAAyCgC,cAAzC;QACAF,OAAOL,GAAP;MAAO,CAHT;;MAMA,KAAK/B,gBAAL,CAAsB,SAAtB,EAAiCqC,SAAjC;MACA,KAAKrC,gBAAL,CAAsB,cAAtB,EAAsCsC,cAAtC;IAAsC,CAhBjC,CAAP;EAgBwC;;EAO1CC,QAAc;IACZ,KAAK1H,OAAL,CAAa,EAAb;EAAa;;EA2BTiB,SACJC,UADI,EAEJzB,OAFI,EAGuB;IAAA;MAC3B,MAAMnB,MAAM,MAAM,KAAKqC,MAAL,CAAYM,QAAZ,CAAqBC,UAArB,EAAiCpB;QACjDK,cAAc,KAAKA;MAD8B,GAE9CV,OAF8C,CAAjC,CAAlB;MAKA,KAAKqG,IAAL,CAAU,UAAV,EAAsBxH,GAAtB;MACA,OAAOA,GAAP;IAAO,CAPoB;EAOpB;;EAYT6C,YAAYD,UAAZ,EAA6C;IAC3C,IAAI,CAAC,KAAKP,MAAL,CAAYQ,WAAjB,EAA8B;MAC5B,OAAO,IAAP;IAAO;;IAGT,OAAO,KAAKR,MAAL,CAAYQ,WAAZ,CAAwBD,UAAxB,CAAP;EAA+B;;EAYjCW,WAAWX,UAAX,EAA4C;IAC1C,IAAI,CAAC,KAAKP,MAAL,CAAYkB,UAAjB,EAA6B;MAC3B,OAAO,IAAP;IAAO;;IAGT,OAAO,KAAKlB,MAAL,CAAYkB,UAAZ,CAAuBX,UAAvB,CAAP;EAA8B;;EAMhC8F,QAAc;IACZzB,mBAAKwB,MAAL,EAAYC,KAAZ;;IACAN,mBAAKK,MAAL,EAAcN,uBAAd;EAAc;;AAlPkD,CAL7D;AA4BLQ;AAiFAF;AAEAJ,iC;;ACnNF,6BACEgB,OADF,EAE4E;EAC1E,MAAM;IAAEC;EAAF,IAAiBD,OAAvB;EACA,OAAO7H,mBACF8H,UADE,CAAP;AACK","names":["SEARCH_URL","ENDPOINT_SUGGEST","ENDPOINT_RETRIEVE","ENDPOINT_FORWARD","ENDPOINT_REVERSE","SUGGEST_URL","RETRIEVE_URL","FORWARD_URL","PERMANENT_FORWARD_URL","REVERSE_URL","PERMANENT_REVERSE_URL","constructor","lng","lat","isNaN","Error","toArray","toString","input","LngLat","Array","isArray","length","Number","lon","sw","ne","_sw","convert","_ne","getSouthWest","getNorthEast","getNorthWest","getWest","getNorth","getSouthEast","getEast","getSouth","toFlatArray","LngLatBounds","randomString","Math","random","Date","now","uuidString","replace","uuid","slice","join","id","generateUUID","token","SessionToken","UNKNOWN_ERROR","json","statusCode","String","message","error","name","res","ok","MapboxError","status","_fetchImpl","globalThis","fetch","_abortControllerImpl","AbortController","force","params","objects","obj","entries","Object","key","value","push","encodeURIComponent","options","__privateAdd","_a","accessToken","defaults","__spreadValues","_MapboxSearch","suggest","searchText","optionsArg","sessionToken","signal","__spreadProps","eta_type","origin","navigation_profile","url","URL","search","__privateMethod","_getQueryParams","getQueryParams_fn","getFetch","handleNonOkRes","retrieve","suggestion","canRetrieve","sessionTokenLike","queryParams","access_token","session_token","_getFetchInfo","getFetchInfo_fn","action","method","endpoint","canSuggest","forward","_0","baseUrl","permanent","reverse","lngLat","language","limit","types","country","proximity","bbox","body","JSON","stringify","headers","MapboxSearch","SEARCH_URL2","ENDPOINT_SUGGEST2","ENDPOINT_RETRIEVE2","SUGGEST_URL2","RETRIEVE_URL2","_MapboxAutofill","_getQueryParams2","getQueryParams_fn2","suggestions","map","original_search_text","streets","MapboxAutofill","SEARCH_URL3","ENDPOINT_VALIDATE","VALIDATE_URL","_MapboxValidate","validate","_getQueryParams3","getQueryParams_fn3","features","MapboxValidate","SEARCH_URL4","TEMP_URL","PERMANENT_URL","_getQueryParams4","getQueryParams_fn4","fetchInit","isReverse","forEach","autocomplete","fuzzyMatch","routing","worldview","MatchCodeConfidence","MatchCodeConfidence2","addEventListener","type","listener","listenersArr","__privateGet","_listeners","removeEventListener","listeners","index","indexOf","splice","fire","arg0","func","wait","signalFn","timeout","args","clearTimeout","setTimeout","aborted","Evented","createAbortController","__privateSet","_suggestDebounce","debounce","_1","__async","_abort","abort","_suggestions","err","defineProperties","writable","Promise","resolve","reject","suggestFn","suggestErrorFn","clear","feature","properties"],"sources":["/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/search/constants.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/LngLat.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/LngLatBounds.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/utils/uuid.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/SessionToken.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/MapboxError.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/fetch.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/utils/queryParams.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/search/MapboxSearch.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/autofill/constants.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/autofill/MapboxAutofill.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/validate/constants.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/validate/MapboxValidate.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/geocode/constants.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/geocode/MapboxGeocode.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/types.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/utils/Evented.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/utils/debounce.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/SearchSession.ts","/Users/akshayrajendraprasad/bedbugsversion2/bedbugsversion2/node_modules/@mapbox/search-js-core/src/featureToSuggestion.ts"],"sourcesContent":["export const SEARCH_URL = `https://api.mapbox.com/search/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\nexport const ENDPOINT_FORWARD = 'forward';\nexport const ENDPOINT_REVERSE = 'reverse';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\nexport const FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nexport const PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\n\nexport const REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nexport const PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;\n","/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n * These coordinates use longitude, latitude coordinate order (as opposed to latitude, longitude)\n * to match the [GeoJSON specification](https://datatracker.ietf.org/doc/html/rfc7946#section-4),\n * which is equivalent to the OGC:CRS84 coordinate reference system.\n *\n * Note that any method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @class LngLat\n * @param lng - Longitude, measured in degrees.\n * @param lat - Latitude, measured in degrees.\n * @example\n * ```typescript\n * const ll = new LngLat(-123.9749, 40.7736);\n * console.log(ll.lng); // = -123.9749\n * ```\n */\nexport class LngLat {\n  /**\n   * @name lng\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lng: number;\n  /**\n   * @name lat\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lat: number;\n\n  constructor(lng: number, lat: number) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\n        'Invalid LngLat latitude value: must be between -90 and 90'\n      );\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\n        'Invalid LngLat longitude value: must be between -180 and 180'\n      );\n    }\n  }\n\n  /**\n   * Returns the coordinates represented as an array of two numbers.\n   *\n   * @returns The coordinates represeted as an array of longitude and latitude.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toArray(); // = [-73.9749, 40.7736]\n   * ```\n   */\n  toArray(): [number, number] {\n    return [this.lng, this.lat];\n  }\n\n  /**\n   * Returns the coordinates represent as a string.\n   *\n   * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n   * ```\n   */\n  toString(): string {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  /**\n   * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n   * to a `LngLat` object.\n   *\n   * If a `LngLat` object is passed in, the function returns a copy.\n   *\n   * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.\n   * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n   * @example\n   * ```typescript\n   * const arr = [-73.9749, 40.7736];\n   * const ll = LngLat.convert(arr);\n   * console.log(ll);   // = LngLat {lng: -73.9749, lat: 40.7736}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLat\n      | { lng: number; lat: number }\n      | { lon: number; lat: number }\n      | [number, number]\n  ): LngLat {\n    // Make a copy if already an LngLat.\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (\n      !Array.isArray(input) &&\n      typeof input == 'object' &&\n      input !== null &&\n      ('lng' in input || 'lon' in input) &&\n      'lat' in input\n    ) {\n      return new LngLat(\n        Number('lng' in input ? input.lng : input.lon),\n        Number(input.lat)\n      );\n    }\n\n    throw new Error(\n      '`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef LngLatLike\n * @type {LngLat | [number, number] | { lng: number, lat: number } | { lon: number, lat: number }}\n * @example\n * ```typescript\n * const v1 = new LngLat(-122.420679, 37.772537);\n * const v2 = [-122.420679, 37.772537];\n * const v3 = {lon: -122.420679, lat: 37.772537};\n * ```\n */\nexport type LngLatLike =\n  | LngLat\n  | { lng: number; lat: number }\n  | { lon: number; lat: number }\n  | [number, number];\n","import { LngLat, LngLatLike } from './LngLat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * Note that any method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @class LngLatBounds\n */\nexport class LngLatBounds {\n  private _ne: LngLat;\n  private _sw: LngLat;\n\n  /**\n   * @param sw - The southwest corner of the bounding box.\n   * @param ne - The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const sw = new LngLat(-73.9876, 40.7661);\n   * const ne = new LngLat(-73.9397, 40.8002);\n   * const llb = new LngLatBounds(sw, ne);\n   * ```\n   */\n  constructor(sw: LngLatLike, ne: LngLatLike) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  /**\n   * Returns the southwest corner of the bounding box.\n   *\n   * @returns The southwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthWest(); // LngLat {lng: -73.9876, lat: 40.7661}\n   * ```\n   */\n  getSouthWest(): LngLat {\n    return this._sw;\n  }\n\n  /**\n   * Returns the northeast corner of the bounding box.\n   *\n   * @returns The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthEast(); // LngLat {lng: -73.9397, lat: 40.8002}\n   * ```\n   */\n  getNorthEast(): LngLat {\n    return this._ne;\n  }\n\n  /**\n   * Returns the northwest corner of the bounding box. This is commonly used\n   * as the 'min' point in the bounding box.\n   *\n   * @returns The northwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthWest(); // LngLat {lng: -73.9876, lat: 40.8002}\n   * ```\n   */\n  getNorthWest(): LngLat {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  /**\n   * Returns the southeast corner of the bounding box. This is commonly used\n   * as the 'max' point in the bounding box.\n   *\n   * @returns The southeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthEast(); // LngLat {lng: -73.9397, lat: 40.7661}\n   * ```\n   */\n  getSouthEast(): LngLat {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  /**\n   * Returns the west edge of the bounding box.\n   *\n   * @returns The west edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getWest(); // -73.9876\n   * ```\n   */\n  getWest(): number {\n    return this._sw.lng;\n  }\n\n  /**\n   * Returns the south edge of the bounding box.\n   *\n   * @returns The south edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouth(); // 40.7661\n   * ```\n   */\n  getSouth(): number {\n    return this._sw.lat;\n  }\n\n  /**\n   * Returns the east edge of the bounding box.\n   *\n   * @returns The east edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getEast(); // -73.9397\n   * ```\n   */\n  getEast(): number {\n    return this._ne.lng;\n  }\n\n  /**\n   * Returns the north edge of the bounding box.\n   *\n   * @returns The north edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorth(); // 40.8002\n   * ```\n   */\n  getNorth(): number {\n    return this._ne.lat;\n  }\n\n  /**\n   * Returns the bounding box represented as an array.\n   *\n   * @returns The bounding box represented as an array, consisting of the\n   *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n   * ```\n   */\n  toArray(): [[number, number], [number, number]] {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  /**\n   * Returns the bounding box represented as a flattened array.\n   *\n   * @returns The bounding box represented as an array of numbers in [west, south, east, north] order.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toFlatArray(); // = [-73.9876, 40.7661, -73.9397, 40.8002]\n   * ```\n   */\n  toFlatArray(): [number, number, number, number] {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  /**\n   * Return the bounding box represented as a string.\n   *\n   * @returns The bounding box represents as a string of the format\n   *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n   * ```\n   */\n  toString(): string {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  /**\n   * Converts an array to a `LngLatBounds` object.\n   *\n   * If a `LngLatBounds` object is passed in, the function returns a copy.\n   *\n   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n   *\n   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.\n   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n   * @example\n   * ```typescript\n   * const arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n   * const llb = LngLatBounds.convert(arr);\n   * console.log(llb);   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLatBounds\n      | [LngLatLike, LngLatLike]\n      | [number, number, number, number]\n  ): LngLatBounds {\n    if (!input) {\n      throw new Error('Invalid LngLatBounds convert value: falsy');\n    }\n\n    // Make a copy if already an LngLatBounds.\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(\n        LngLat.convert(input[0]),\n        LngLat.convert(input[1])\n      );\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(\n        LngLat.convert([input[0], input[1]]),\n        LngLat.convert([input[2], input[3]])\n      );\n    }\n\n    throw new Error(\n      '`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef LngLatBoundsLike\n * @type {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]}\n * @example\n * ```typescript\n * const v1 = new LngLatBounds(\n *   new LngLat(-73.9876, 40.7661),\n *   new LngLat(-73.9397, 40.8002)\n * );\n * const v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n * const v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n * ```\n */\nexport type LngLatBoundsLike =\n  | LngLatBounds\n  | [LngLatLike, LngLatLike]\n  | [number, number, number, number];\n","const UUID_RE =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Validates the UUID v4.\n * @param id - UUID value.\n */\nexport function validateUUID(id: string): boolean {\n  return UUID_RE.test(id);\n}\n\n/**\n * Generates a RFC4122 v4 UUID (pseudo-randomly-based)\n *\n * IMPORTANT: THIS IS NOT CRYPTO-GRAPHICALLY SECURE!\n *\n * Since we're using this to generate a random UUID, essentially as an SKU,\n * we don't need to worry about the randomness of the values as much.\n */\nexport function generateUUID(): string {\n  const randomString =\n    Math.random().toString(16) +\n    Date.now().toString(16) +\n    Math.random().toString(16);\n\n  const uuidString = randomString.replace(/\\./g, '');\n\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    '4' + uuidString.slice(12, 15) + '-8' + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join('-');\n\n  return uuid;\n}\n","import { generateUUID } from './utils/uuid';\n\n/**\n * A `SessionToken` object is a unique identifier that groups together `suggest` / `retrieve` calls as part of the\n * [Mapbox Search API](https://docs.mapbox.com/api/search/search/#retrieve-a-suggestion).\n *\n * Session tokens are used for [billing](https://docs.mapbox.com/api/search/search/#search-api-pricing) and\n * customer-accessible analytics.\n *\n * A [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value is recommended,\n * and is generated if an `id` is not provided.\n *\n * Note that any method that accepts a `SessionToken` object as an argument or option\n * can also accept a unique `string` and will perform an implicit conversion.\n * This flexible type is documented as {@link SessionTokenLike}.\n *\n * @name SessionToken\n * @example\n * ```typescript\n * const token = new SessionToken();\n * console.log(token.id); // = I am a UUIDv4 value!\n * ```\n */\nexport class SessionToken {\n  /**\n   * The session token in string format.\n   */\n  readonly id: string;\n\n  constructor(id?: string) {\n    this.id = id ?? generateUUID();\n  }\n\n  /**\n   * Returns the session token in string format.\n   *\n   * This is the same as calling `token.id`, and is okay to be used for serialization.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Converts a string to a `SessionToken` object.\n   *\n   * If a `SessionToken` object is passed in, the function returns a copy.\n   */\n  static convert(token: SessionToken | string): SessionToken {\n    return new SessionToken(\n      token instanceof SessionToken ? token.id : token.toString()\n    );\n  }\n}\n\n/**\n * A {@link SessionToken} object or string representing a Mapbox Search API session token.\n *\n * It's recommended this value is a [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value.\n *\n * @typedef SessionTokenLike\n * @type {SessionToken | string}\n * @example\n * const v1 = new SessionToken();\n * const v2 = new SessionToken('f06e7531-6373-4d5a-8614-b6f313488050');\n * const v3 = 'f06e7531-6373-4d5a-8614-b6f313488050';\n */\nexport type SessionTokenLike = string | SessionToken;\n","export const UNKNOWN_ERROR = 'Unknown error';\n\n/**\n * Thrown from Search JS Core functions when a network request fails.\n *\n * See common errors here:\n * - [MapboxSearch](https://docs.mapbox.com/api/search/search/#search-api-errors)\n * - [MapboxAutofill](https://docs.mapbox.com/api/search/geocoding/#geocoding-api-errors)\n */\nexport class MapboxError extends Error {\n  readonly statusCode: number;\n\n  constructor(json: Record<string, unknown>, statusCode: number) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = 'MapboxError';\n    this.statusCode = statusCode;\n  }\n\n  /**\n   * Modified Error toString() method to include the status code.\n   */\n  toString(): string {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n}\n\n/**\n * Utility function to see if the result is \"ok\" (in 200 range).\n *\n * If not, throw a {@link MapboxError} filled out by the\n * [JSON error format](https://docs.mapbox.com/api/search/search/#search-api-errors).\n */\nexport async function handleNonOkRes(res: Response): Promise<void> {\n  if (!res.ok) {\n    const json = await res.json();\n    throw new MapboxError(json, res.status);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// GLOBALS\nlet _fetchImpl: typeof fetch = globalThis.fetch;\nlet _abortControllerImpl: typeof AbortController = globalThis.AbortController;\n\ninterface FetchImplementation {\n  fetch: typeof fetch;\n  AbortController: typeof AbortController;\n}\n\n/**\n * Polyfills {@link fetch} implementation used in Search JS Core.\n *\n * If a `fetch` implementation is already available, the polyfill will be\n * silently ignored.\n *\n * When running Search JS Core in a Node.js environment, fetch must be either\n * polyfilled globally or passed into this function before usage of\n * internal library functionality.\n *\n * @param opts Options for the polyfill.\n * @param {fetch} opts.fetch Required. A custom `fetch` implementation.\n * @param {AbortController} opts.AbortController Required. A custom `AbortController` implementation.\n * @param {boolean} force If `true`, the polyfill will be forced to load. Otherwise, it will only load if `fetch` is not available.\n */\nexport function polyfillFetch(\n  { fetch, AbortController }: FetchImplementation,\n  force = false\n): void {\n  if (!fetch) {\n    throw new Error(\n      'Fetch implementation must include implementations of `fetch`.'\n    );\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\n/**\n * Returns the {@link FetchImplementation} used by Search JS Core.\n */\nexport function getFetch(): FetchImplementation {\n  if (!_fetchImpl) {\n    throw new Error(\n      'Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.'\n    );\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n","type Primitive = string | number | boolean | null;\n\n/**\n * tl;dr - [classnames](https://www.npmjs.com/package/classnames) for query parameters.\n *\n * Encodes query parameters into a stringified form, good for use with {@link URL#search}.\n * Objects are key-value pairs, and if a falsy object is passed, it will be omitted.\n *\n * Null and undefined values are ignored.\n * Array values are encoded as comma-separated values.\n *\n * @example\n * ```typescript\n * const limit = 0;\n * const offset = null;\n * const params = queryParams(\n *  {\n *    q: 'pizza',\n *    c: null\n *  },\n *  (limit != null) && { limit },\n *  (offset != null) && { offset }\n * );\n * console.log(params); // = 'q=pizza&limit=0'\n * ```\n */\nexport function queryParams<T extends Record<string, Primitive>>(\n  ...objects: (T | false)[]\n): string {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join('&');\n}\n","import {\n  ENDPOINT_RETRIEVE,\n  ENDPOINT_SUGGEST,\n  FORWARD_URL,\n  PERMANENT_FORWARD_URL,\n  PERMANENT_REVERSE_URL,\n  RETRIEVE_URL,\n  REVERSE_URL,\n  SUGGEST_URL\n} from './constants';\nimport {\n  AdministrativeUnitTypes,\n  Suggestion,\n  FeatureSuggestion\n} from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism works in the same way as the [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests\n   * together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef Options\n */\nexport interface Options {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * The navigation routing profile to use for distance/eta calculations.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  navigation_profile?: 'driving' | 'walking' | 'cycling';\n  /**\n   * The location from which to calculate distance. **This parameter may incur additional latency.**\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  origin: string | LngLatLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Used to estimate the time of arrival from {@link Options#origin}. **This parameter may incur additional latency.**\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  eta_type?: 'navigation';\n  /**\n   * Limit results to one or more types of features. If no types are specified, all possible types may be returned.\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#administrative-unit-types\n   */\n  types?: string | Set<AdministrativeUnitTypes>;\n}\n\ninterface PermanentOptions {\n  /**\n   * The permanent endpoints are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * @typedef SuggestionResponse\n */\nexport interface SuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: Suggestion[];\n}\n\n/**\n * @typedef RetrieveResponse\n */\nexport interface RetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: FeatureSuggestion[];\n}\n\n/**\n * A `MapboxSearch` object is an application's main entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/).\n *\n * `MapboxSearch` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxSearch#suggest}: The user enters a search term, and a list of suggested results is returned with\n *      optional data such as: eta, distance calculations, etc.\n *   2. {@link MapboxSearch#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned for displaying on a map or otherwise manipulating.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxSearch`, and\n * other options may be specified either in the constructor or in the {@link MapboxSearch#suggest} call.\n *\n * @class MapboxSearch\n * @param {Options} [options]\n * @param {string} [options.accessToken]\n *\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const sessionToken = new SessionToken();\n * const result = await search.suggest('Washington D.C.', { sessionToken });\n * if (result.suggestions.length === 0) return;\n *\n * const suggestion = result.suggestions[0];\n * if (search.canRetrieve(suggestion)) {\n *  const { features } = await search.retrieve(suggestion, { sessionToken });\n *  doSomethingWithCoordinates(features);\n * } else if (search.canSuggest(suggestion)) {\n *   // .. go through suggest flow again ..\n * }\n * ```\n */\nexport class MapboxSearch {\n  static defaults: Partial<Options> = {\n    language: 'en'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link Options}) to be merged into options in the following methods:\n   * - {@link MapboxSearch#suggest}\n   * - {@link MapboxSearch#forward}\n   * - {@link MapboxSearch#reverse}\n   */\n  defaults: Partial<Options>;\n\n  constructor(options: Partial<AccessTokenOptions & Options> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxSearch.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Interactive search} */\n\n  /**\n   * {@link MapboxSearch#suggest} is \"part one\" of the two-step interactive search experience, and includes\n   * useful information such as: {@link Suggestion#feature_name}, {@link Suggestion#description}, and {@link Suggestion#maki}.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * It may be useful to call {@link MapboxSearch#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link MapboxSearch#canSuggest}, and further calls to {@link MapboxSearch#suggest}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {string} searchText\n   * @param {Options} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & Options>\n  ): Promise<SuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n      throw new Error(\n        'to provide eta estimate: eta, navigation_profile, and origin are required'\n      );\n    }\n    if (options.origin && !options.navigation_profile) {\n      throw new Error(\n        'to provide distance estimate: both navigation_profile and origin are required'\n      );\n    }\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as SuggestionResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link MapboxSearch#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * feature suggestions should come from the {@link MapboxSearch#forward} method\n   * with {@link PermanentOptions#permanent} enabled.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {any} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<RetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(RETRIEVE_URL);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      ...this.#getFetchInfo(suggestion),\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  /** @section {Programmatic search} */\n\n  /**\n   * {@link MapboxSearch#forward} is our programmatic one-step search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async forward(\n    searchText: string,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#reverse} allows you to look up a geographic coordinate pair\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param lngLat - Either a {@link LngLatLike} object or string in 'lng,lat' comma-separated format.\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n\n    const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxSearch#suggest} and\n   * {@link MapboxSearch#forward}.\n   */\n  #getQueryParams(options: Partial<Options & SessionTokenOptions>): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        navigation_profile: options.navigation_profile,\n        eta_type: options.eta_type\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.origin && {\n        origin:\n          typeof options.origin === 'string'\n            ? options.origin\n            : LngLat.convert(options.origin).toArray().join(',')\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n\n  /**\n   * Gets a partial fetch request from this suggestion's action.\n   */\n  #getFetchInfo(suggestion: Suggestion): Partial<RequestInit> {\n    if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n      throw new Error('Suggestion cannot be retrieved or suggested');\n    }\n\n    const action = suggestion.action;\n    const body = JSON.stringify(action.body);\n\n    return {\n      method: action.method,\n      body,\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body.length.toString()\n      }\n    };\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n","import { RETRIEVE_URL, SUGGEST_URL } from './constants';\nimport { AutofillSuggestion, AutofillFeatureSuggestion } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef AutofillOptions\n */\nexport interface AutofillOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link AutofillOptions#proximity} and {@link AutofillOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef AutofillSuggestionResponse\n */\nexport interface AutofillSuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: AutofillSuggestion[];\n}\n\n/**\n * @typedef AutofillRetrieveResponse\n */\nexport interface AutofillRetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: AutofillFeatureSuggestion[];\n}\n\n/**\n * A `MapboxAutofill` object is an application's main entrypoint to the\n * Mapbox Autofill API. The Mapbox Autofill API is an API similar to {@link MapboxSearch},\n * but targeted towards **address** autocomplete.\n *\n * Only address types are returned by the API.\n *\n * `MapboxAutofill` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxAutofill#suggest}: The user enters a search term, and a list of suggested results is returned with\n *     address data.\n *   2. {@link MapboxAutofill#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxAutofill`, and\n * other options may be specified either in the constructor or in the {@link MapboxAutofill#suggest} call.\n *\n * @class MapboxAutofill\n * @param {AutofillOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxAutofill {\n  static defaults: Partial<AutofillOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link AutofillOptions}) to be merged into options in the following methods:\n   * - {@link MapboxAutofill#suggest}\n   *\n   * @type {AutofillOptions}\n   */\n  defaults: Partial<AutofillOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & AutofillOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxAutofill.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxAutofill#suggest} is \"part one\" of the two-step autofill experience, and includes\n   * autofill information.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & AutofillOptions>\n  ): Promise<AutofillSuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillSuggestionResponse;\n\n    // Add 'original_search_text' so we can retrieve.\n    return {\n      ...json,\n      suggestions: json.suggestions.map((suggestion) => {\n        return {\n          ...suggestion,\n          original_search_text: searchText\n        };\n      })\n    };\n  }\n\n  /**\n   * {@link MapboxAutofill#retrieve} is \"part two\" of the two-step autofill experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link AutofillSuggestion} returned from \"part one,\"\n   * {@link MapboxAutofill#suggest}.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: AutofillSuggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<AutofillRetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), { signal });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillRetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxAutofill#suggest}\n   */\n  #getQueryParams(\n    options: Partial<AutofillOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        types: 'address',\n        streets: true,\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n\n  /**\n   * Returns true if {@link MapboxAutofill#retrieve} can be called on this suggestion,\n   * false otherwise.\n   */\n  canRetrieve(suggestion: AutofillSuggestion): boolean {\n    const action = suggestion.action;\n\n    return typeof action?.id === 'string';\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_VALIDATE = 'retrieve';\n\nexport const VALIDATE_URL = `${SEARCH_URL}/${ENDPOINT_VALIDATE}`;\n","import { VALIDATE_URL } from './constants';\nimport { ValidateFeature } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef ValidateOptions\n */\nexport interface ValidateOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link ValidateOptions#proximity} and {@link ValidateOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef ValidateResponse\n */\nexport interface ValidateResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: ValidateFeature[];\n}\n\n/**\n * A `MapboxValidate` object is an application's main entrypoint to the\n * Mapbox Validate API. The Mapbox Validate API is an API similar to {@link MapboxAutofill},\n * but targeted at checking **address**.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxValidate`, and\n * other options may be specified either in the constructor or in the {@link MapboxValidate#validate} call.\n *\n * @class MapboxValidate\n * @param {ValidateOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxValidate {\n  static defaults: Partial<ValidateOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link ValidateOptions}) to be merged into options in the following methods:\n   * - {@link ValidateOptions#validate}\n   *\n   * @type {ValidateOptions}\n   */\n  defaults: Partial<ValidateOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & ValidateOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxValidate.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxValidate#validate} allows you to validate an address\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async validate(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<ValidateResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as ValidateResponse;\n\n    if (json.features.length > 0) {\n      json.features = [json.features[0]];\n    }\n\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxValidate#validate}\n   */\n  #getQueryParams(\n    options: Partial<ValidateOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/geocoding/v5`;\n\nexport const TEMP_URL = `${SEARCH_URL}/mapbox.places`;\nexport const PERMANENT_URL = `${SEARCH_URL}/mapbox.places-permanent`;\n","import { getFetch } from '../fetch';\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { handleNonOkRes } from '../MapboxError';\nimport { queryParams } from '../utils/queryParams';\nimport { PERMANENT_URL, TEMP_URL } from './constants';\nimport { DataTypes, GeocodeFeature } from './types';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @typedef GeocodeOptions\n */\nexport interface GeocodeOptions {\n  /**\n   * When autocomplete is enabled, results will be included that start with the requested string, rather than just responses that match it exactly.\n   *\n   * Defaults to true.\n   */\n  autocomplete: boolean;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * Limit results to one or more countries. Permitted values are [ISO 3166 alpha 2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country codes separated by commas.\n   */\n  country: string;\n  /**\n   * Specify whether the Geocoding API should attempt approximate, as well as exact, matching when performing searches.\n   *\n   * Defaults to true.\n   */\n  fuzzyMatch: boolean;\n  /**\n   * An [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) that controls the language of the text supplied in responses, and also affects result scoring.\n   */\n  language: string;\n  /**\n   * The number of results to return, up to `10`.\n   *\n   * Defaults to 5.\n   */\n  limit: number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * Provided as two comma-separated coordinates in longitude,latitude order, or the string `ip` to bias based on reverse IP lookup.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Specify whether to request additional metadata about the recommended navigation destination corresponding to the feature (`true`) or not (`false`, default). Only applicable for address features.\n   */\n  routing: boolean;\n  /**\n   * Filter results to include only a subset (one or more) of the available feature types. Multiple options can be comma-separated.\n   */\n  types: string | Set<DataTypes>;\n  /**\n   * Available worldviews are: `cn`, `in`, `jp`, `us`. If a worldview is not set, `us` worldview boundaries will be returned.\n   */\n  worldview: string;\n}\n\ninterface PermanentOptions {\n  /**\n   * Permanent geocodes are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * A `GeocodeResponse` object represents a returned data object from the [Mapbox Geocoding API](https://docs.mapbox.com/api/search/geocoding/#geocoding-response-object).\n *\n * @typedef GeocodeResponse\n */\nexport interface GeocodeResponse {\n  /**\n   * `\"FeatureCollection\"`, a GeoJSON type from the [GeoJSON specification](https://tools.ietf.org/html/rfc7946).\n   */\n  type: 'FeatureCollection';\n  /**\n   * Forward geocodes: An array of space and punctuation-separated strings from the original query.\n   *\n   * Reverse geocodes: An array containing the coordinates being queried.\n   */\n  query: string[];\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link GeocodeFeature}\n   */\n  features: GeocodeFeature[];\n  /**\n   * Attributes the results of the Mapbox Geocoding API to Mapbox.\n   */\n  attribution: string;\n}\n\n/**\n * A `MapboxGeocode` object is an application's main entrypoint to the [Mapbox Geocoding API](https://docs.mapbox.com/api/search/geocoding/).\n * The Geocoding API allows forward (location to coordinates) and reverse (coordinates to location) queries, enabled by corresponding\n * methods from the `MapboxGeocode` object.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxGeocode`, and\n * other options may be specified either in the constructor or in the {@link MapboxGeocode#forward} or {@link MapboxGeocode#reverse} calls.\n *\n * @class MapboxGeocode\n *\n * @example\n * ```typescript\n * const geocode = new MapboxGeocode({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const results = await geocode.forward('Washington D.C.');\n * if (results.features.length === 0) return;\n *\n * const feature = results.features[0];\n * doSomethingWithCoordinates(feature);\n * ```\n */\nexport class MapboxGeocode {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link GeocodeOptions}) to be merged into options in the following methods:\n   * - {@link MapboxGeocode#forward}\n   * - {@link MapboxGeocode#reverse}\n   */\n  defaults: Partial<GeocodeOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & GeocodeOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxGeocode#forward} allows you to look up a single location by name\n   * and returns the feature(s) and corresponding geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, geographic coordinates should be used ephemerally and not persisted.\n   * If the results are to be cached/stored in a customer database,\n   * calls to {@link MapboxGeocode#forward} should specify `permanent: true` within the method options argument.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {GeocodeOptions} [optionsArg]\n   * @param {AbortSignal} [optionsArg.signal]\n   *\n   * @example\n   * ```typescript\n   * const results = await geocode.forward('Washington D.C.');\n   * if (results.features.length === 0) return;\n   *\n   * const feature = results.features[0];\n   * doSomethingWithCoordinates(feature);\n   * ```\n   */\n  async forward(\n    searchText: string,\n    optionsArg?: Partial<FetchOptions & GeocodeOptions & PermanentOptions>\n  ): Promise<GeocodeResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    let signal: AbortSignal;\n    if (optionsArg) {\n      ({ signal } = optionsArg);\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const fetchInit = signal ? { signal } : {};\n    const res = await fetch(url.toString(), fetchInit);\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as GeocodeResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxGeocode#reverse} allows you to look up a single pair of coordinates and returns the\n   * geographic feature or features that exist at that location in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, geographic coordinates should be used ephemerally and not persisted.\n   * If the results are to be cached/stored in a customer database,\n   * calls to {@link MapboxGeocode#reverse} should specify `permanent: true` within the method options argument.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {GeocodeOptions} [optionsArg]\n   * @param {AbortSignal} [optionsArg.signal]\n   *\n   * @example\n   * ```typescript\n   * const results = await geocode.reverse({ lat: 40.7736, lng: -73.9749 });\n   * if (results.features.length === 0) return;\n   *\n   * const feature = results.features[0];\n   * doSomethingWithFeature(feature);\n   * ```\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg?: Partial<FetchOptions & GeocodeOptions & PermanentOptions>\n  ): Promise<GeocodeResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n\n    let signal: AbortSignal;\n    if (optionsArg) {\n      ({ signal } = optionsArg);\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n    const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n    url.search = this.#getQueryParams(options, true);\n\n    const { fetch } = getFetch();\n    const fetchInit = signal ? { signal } : {};\n    const res = await fetch(url.toString(), fetchInit);\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as GeocodeResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link <MapboxGeocode>#forward} and {@link <MapboxGeocode>#reverse}\n   */\n  #getQueryParams(options: Partial<GeocodeOptions>, isReverse = false): string {\n    // Remove query parameters that don't apply to forward or reverse\n    if (isReverse) {\n      ['proximity', 'autocomplete', 'fuzzyMatch', 'bbox'].forEach((key) => {\n        if (key in options) {\n          delete options[key];\n        }\n      });\n    }\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        autocomplete: options.autocomplete,\n        fuzzyMatch: options.fuzzyMatch,\n        routing: options.routing,\n        worldview: options.worldview\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n}\n","/**\n * @typedef MatchCodeConfidence\n */\nexport const enum MatchCodeConfidence {\n  /**\n   * An exact match.\n   */\n  exact = 'exact',\n  /**\n   * High confidence of a match.\n   */\n  high = 'high',\n  /**\n   * Medium confidence of a match.\n   */\n  medium = 'medium',\n  /**\n   * Low confidence of a match.\n   */\n  low = 'low'\n}\n\n/**\n * An object describing the level of confidence that the given response feature matches the address intended by the request query.\n * Includes boolean flags denoting matches for each address sub-component.\n *\n * @typedef MatchCode\n */\nexport interface MatchCode {\n  /**\n   * A measure of confidence that the returned feature suggestion matches the intended address, based on the search text provided.\n   */\n  confidence: MatchCodeConfidence;\n  /**\n   * True if the confidence value is \"exact\".\n   */\n  exact_match: boolean;\n  /**\n   * True if the house number component was matched.\n   */\n  house_number: boolean;\n  /**\n   * True if the street component was matched.\n   */\n  street: boolean;\n  /**\n   * True if the postcode was matched.\n   */\n  postcode: boolean;\n  /**\n   * True if the place component was matched.\n   */\n  place: boolean;\n  /**\n   * True if the region component was matched.\n   */\n  region?: boolean;\n  /**\n   * True if the locality component was matched.\n   */\n  locality?: boolean;\n}\n","/**\n * `Evented` mixes methods into other classes for event capabilities.\n *\n * If you are an end-user, you will most likely use these methods through\n * classes like {@link SearchSession}.\n *\n * For lists of events you can listen for, see API documentation for\n * specific classes.\n *\n * @class Evented\n */\nexport class Evented<T> {\n  #listeners: Partial<{\n    [key in keyof T]: ((arg0: T[key]) => void)[];\n  }> = {};\n\n  /**\n   * Adds a listener to a specified event type.\n   *\n   * @param type - The event type to add a listen for.\n   * @param listener - The function to be called when the event is fired.\n   */\n  addEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // Create listener if doesn't already exist.\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   *\n   * @param type - The event type to remove listeners for.\n   * @param listener - The listener function to remove.\n   */\n  removeEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire<K extends keyof T>(type: K, arg0: T[K]): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n}\n","/**\n * Version of the classic `debounce` function that accepts a `signalFn`\n * argument, which can return an {@link AbortSignal}.\n */\nexport function debounce<F extends (...args: unknown[]) => unknown>(\n  func: F,\n  wait: number,\n  signalFn?: () => AbortSignal\n): F {\n  let timeout = null;\n\n  return ((...args: Parameters<F>) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal?.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  }) as F;\n}\n","/* eslint-disable prefer-const */\nimport { SessionToken, SessionTokenLike } from './SessionToken';\n\nimport { getFetch } from './fetch';\n\nimport { Evented } from './utils/Evented';\nimport { debounce } from './utils/debounce';\n\n/**\n * Shortcut function to create a new AbortController from the polyfill.\n */\nfunction createAbortController(): AbortController {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\n\ninterface EventTypes<SuggestionResponse, RetrieveResponse> {\n  suggest: SuggestionResponse;\n  suggesterror: Error;\n  retrieve: RetrieveResponse;\n}\n\n/**\n * TypeScript magic section: what is this?\n *\n * Despite the name {@link SearchSession}, in Search JS Web we use it to control\n * both {@link MapboxSearch} **and** {@link MapboxAutofill} instances. Both\n * of these have similar workflows, but are separate APIs with different options\n * and responses.\n *\n * In order to make TypeScript happy, this type is an \"approximation\" of what\n * {@link SearchSession} uses. When you construct a new {@link SearchSession},\n * because of this type [Options, Suggestion, SuggestionResponse, RetrieveResponse]\n * are automatically inferred.\n *\n * @internal\n * @example\n * ```typescript\n * const autofill = new MapboxAutofill({\n *  accessToken: 'pk.my-fancy-token',\n * });\n *\n * const session = new SearchSession(autofill);\n *\n * `session` has inferred type = SearchSession<\n *   AutofillOptions,\n *   AutofillSuggestion,\n *   AutofillSuggestionResponse,\n *   AutofillRetrieveResponse\n * >\n * ```\n */\ntype SuggestSearch<Options, Suggestion, SuggestionResponse, RetrieveResponse> =\n  {\n    suggest: (\n      text: string,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n        signal: AbortSignal;\n      }\n    ) => Promise<SuggestionResponse>;\n    retrieve: (\n      suggestion: Suggestion,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n      }\n    ) => Promise<RetrieveResponse>;\n    canRetrieve?: (suggestion: Suggestion) => boolean;\n    canSuggest?: (suggestion: Suggestion) => boolean;\n  };\n\n/**\n * A `SearchSession` object is a managed entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/)\n * or Mapbox Autocomplete API.\n *\n * `SearchSession` abstracts the suggest/retrieve flow of the two-step interactive search experience.\n *\n * Compared to using these APIs directly, you can use a `SearchSession` to:\n * 1. Automatically manage the session token lifecycle.\n * 2. Debounce calls to {@link SearchSession#suggest}.\n * 2. Abort in-flight requests with an imperative API.\n *\n * @class SearchSession\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n * const session = new SearchSession(search);\n *\n * session.addEventListener('suggest', (res) => {\n *   presentResultsToUser(res.suggestions);\n * });\n *\n * session.addEventListener('retrieve', (res) => {\n *   doSomethingWithFeatureCollection(res);\n * });\n *\n * document.querySelector('button').addEventListener('click', (event) => {\n *   const suggestions = session.suggestions?.suggestions;\n *   if (!suggestions || !suggestions.length) {\n *     return;\n *   }\n *\n *   const suggestion = suggestions[0];\n *   if (session.canRetrieve(suggestion)) {\n *     session.retrieve(suggestion);\n *   } else if (session.canSuggest(suggestion)) {\n *     // .. go through suggest flow again ..\n *     session.suggest(suggestion.text);\n *   }\n * });\n *\n * session.suggest('Washington D.C.');\n * ```\n * @param {MapboxSearch | MapboxAutofill} search - The search interface to wrap.\n * @param {number} wait - The time in milliseconds to wait before sending a new request to the {@link SearchSession#suggest} call.\n */\nexport class SearchSession<\n  Options,\n  Suggestion,\n  SuggestionResponse,\n  RetrieveResponse\n> extends Evented<EventTypes<SuggestionResponse, RetrieveResponse>> {\n  readonly search: SuggestSearch<\n    Options,\n    Suggestion,\n    SuggestionResponse,\n    RetrieveResponse\n  >;\n\n  /**\n   * The time in milliseconds to wait before sending a new request to the\n   * {@link SearchSession#suggest} call.\n   */\n  readonly debounce: number;\n\n  /**\n   * The session token is an SKU (billing token) used to identify the current\n   * search session and provide analytics to the customer.\n   *\n   * As per {@link SessionToken}, this is a UUIDv4 value.\n   *\n   */\n  sessionToken = new SessionToken();\n\n  #suggestions: SuggestionResponse | null;\n\n  /**\n   * The suggestions from the last successful suggest call, if any.\n   */\n  get suggestions(): SuggestionResponse | null {\n    return this.#suggestions;\n  }\n\n  constructor(\n    search: SuggestSearch<\n      Options,\n      Suggestion,\n      SuggestionResponse,\n      RetrieveResponse\n    >,\n    wait = 0\n  ) {\n    super();\n\n    // Set 'suggest' method using debounce.\n    this.#suggestDebounce = debounce(\n      async (\n        searchText: string,\n        options: Partial<Options> = {}\n      ): Promise<void> => {\n        // Refresh abort controller.\n        this.#abort.abort();\n        this.#abort = createAbortController();\n\n        if (!searchText) {\n          this.#suggestions = null;\n          this.fire('suggest', this.#suggestions);\n          return;\n        }\n\n        try {\n          const res = await this.search.suggest(searchText, {\n            sessionToken: this.sessionToken,\n            ...options,\n            signal: this.#abort.signal\n          });\n\n          this.#suggestions = res;\n          this.fire('suggest', res);\n        } catch (err) {\n          if (err.name === 'AbortError') {\n            return;\n          }\n\n          this.fire('suggesterror', err);\n        }\n      },\n      wait,\n      () => this.#abort.signal\n    );\n\n    /**\n     * Define properties using {@link Object#defineProperties} so they are readonly during runtime,\n     * not just in TypeScript.\n     */\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  /**\n   * The {@link AbortController} is used to abort the current suggest, either\n   * because of a new {@link SearchSession#suggest} call, or because\n   * of {@link SearchSession#abort}.\n   *\n   * In both of these cases, a new {@link AbortController} is created,\n   * and the old one is aborted.\n   */\n  #abort = createAbortController();\n\n  #suggestDebounce: (searchText: string, options?: Partial<Options>) => void;\n\n  /** @section {Methods} */\n\n  /**\n   * {@link SearchSession#suggest} is \"part one\" of the two-step interactive search experience,\n   * and each suggestion includes metadata to present to the user.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link SearchSession#retrieve}.\n   *\n   * It may be useful to call {@link SearchSession#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link SearchSession#canSuggest}, and further calls to {@link SearchSession#suggest}.\n   *\n   * Results can be retrieved with the \"suggest\" event.\n   *\n   * @example\n   * ```typescript\n   * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n   * const session = new SearchSession(search);\n   *\n   * session.addEventListener('suggest', (res) => {\n   *   presentResultsToUser(res.suggestions);\n   * });\n   *\n   * session.suggest('Washington D.C.');\n   * ```\n   */\n  suggest(\n    searchText: string,\n    options?: Partial<Options>\n  ): Promise<SuggestionResponse> {\n    this.#suggestDebounce(searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn: (val: SuggestionResponse) => void;\n      let suggestErrorFn: (val: Error) => void;\n\n      suggestFn = (res) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener('suggest', suggestFn);\n      this.addEventListener('suggesterror', suggestErrorFn);\n    });\n  }\n\n  /**\n   * Clears the current suggestions.\n   */\n  clear(): void {\n    this.suggest('');\n  }\n\n  /**\n   * {@link SearchSession#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link SearchSession#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, results should not be stored in a customer database.\n   * Results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    options?: Partial<Options>\n  ): Promise<RetrieveResponse> {\n    const res = await this.search.retrieve(suggestion, {\n      sessionToken: this.sessionToken,\n      ...options\n    });\n\n    this.fire('retrieve', res);\n    return res;\n  }\n\n  /**\n   * Returns true if {@link SearchSession#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  /**\n   * Returns true if {@link SearchSession#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  /**\n   * Aborts the current {@link SearchSession#suggest} request.\n   */\n  abort(): void {\n    this.#abort.abort();\n    this.#abort = createAbortController();\n  }\n}\n","import { FeatureSuggestion, Suggestion } from './search/types';\nimport {\n  AutofillFeatureSuggestion,\n  AutofillSuggestion\n} from './autofill/types';\n\nfunction featureToSuggestion(feature: FeatureSuggestion): Suggestion;\n\nfunction featureToSuggestion(\n  feature: AutofillFeatureSuggestion\n): AutofillSuggestion;\n\n/**\n * Utility function to convert the {@link FeatureSuggestion} properties to a\n * {@link Suggestion} object.\n */\nfunction featureToSuggestion(\n  feature: FeatureSuggestion | AutofillFeatureSuggestion\n): Suggestion | Omit<AutofillSuggestion, 'original_search_text' | 'action'> {\n  const { properties } = feature;\n  return {\n    ...properties\n  };\n}\n\nexport { featureToSuggestion };\n"]},"metadata":{},"sourceType":"module"}