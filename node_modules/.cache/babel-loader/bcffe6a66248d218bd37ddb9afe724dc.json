{"ast":null,"code":"import _assertThisInitialized from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _toConsumableArray from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _inherits from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _classCallCheck from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols(source)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return target;\n};\n\nvar __accessCheck = function __accessCheck(obj, member, msg) {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\n\nvar __privateGet = function __privateGet(obj, member, getter) {\n  __accessCheck(obj, member, \"read from private field\");\n\n  return getter ? getter.call(obj) : member.get(obj);\n};\n\nvar __privateAdd = function __privateAdd(obj, member, value) {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\n\nvar __privateSet = function __privateSet(obj, member, value, setter) {\n  __accessCheck(obj, member, \"write to private field\");\n\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\nvar __privateMethod = function __privateMethod(obj, member, method) {\n  __accessCheck(obj, member, \"access private method\");\n\n  return method;\n};\n\nvar __async = function __async(__this, __arguments, generator) {\n  return new Promise(function (resolve, reject) {\n    var fulfilled = function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = function rejected(value) {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = function step(x) {\n      return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    };\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n}; // src/search/constants.ts\n\n\nvar SEARCH_URL = \"https://api.mapbox.com/search/v1\";\nvar ENDPOINT_SUGGEST = \"suggest\";\nvar ENDPOINT_RETRIEVE = \"retrieve\";\nvar ENDPOINT_FORWARD = \"forward\";\nvar ENDPOINT_REVERSE = \"reverse\";\nvar SUGGEST_URL = \"\".concat(SEARCH_URL, \"/\").concat(ENDPOINT_SUGGEST);\nvar RETRIEVE_URL = \"\".concat(SEARCH_URL, \"/\").concat(ENDPOINT_RETRIEVE);\nvar FORWARD_URL = \"\".concat(SEARCH_URL, \"/\").concat(ENDPOINT_FORWARD);\nvar PERMANENT_FORWARD_URL = \"\".concat(SEARCH_URL, \"/permanent/\").concat(ENDPOINT_FORWARD);\nvar REVERSE_URL = \"\".concat(SEARCH_URL, \"/\").concat(ENDPOINT_REVERSE);\nvar PERMANENT_REVERSE_URL = \"\".concat(SEARCH_URL, \"/permanent/\").concat(ENDPOINT_REVERSE); // src/LngLat.ts\n\nvar LngLat = /*#__PURE__*/function () {\n  function LngLat(lng, lat) {\n    _classCallCheck(this, LngLat);\n\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(\"Invalid LngLat object: (\".concat(lng, \", \").concat(lat, \")\"));\n    }\n\n    this.lng = +lng;\n    this.lat = +lat;\n\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\"Invalid LngLat longitude value: must be between -180 and 180\");\n    }\n  }\n\n  _createClass(LngLat, [{\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.lng, this.lat];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"LngLat(\".concat(this.lng, \", \").concat(this.lat, \")\");\n    }\n  }], [{\n    key: \"convert\",\n    value: function convert(input) {\n      if (input instanceof LngLat) {\n        return new LngLat(input.lng, input.lat);\n      }\n\n      if (Array.isArray(input) && input.length === 2) {\n        return new LngLat(Number(input[0]), Number(input[1]));\n      }\n\n      if (!Array.isArray(input) && typeof input == \"object\" && input !== null && (\"lng\" in input || \"lon\" in input) && \"lat\" in input) {\n        return new LngLat(Number(\"lng\" in input ? input.lng : input.lon), Number(input.lat));\n      }\n\n      throw new Error(\"`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n  }]);\n\n  return LngLat;\n}(); // src/LngLatBounds.ts\n\n\nvar LngLatBounds = /*#__PURE__*/function () {\n  function LngLatBounds(sw, ne) {\n    _classCallCheck(this, LngLatBounds);\n\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  _createClass(LngLatBounds, [{\n    key: \"getSouthWest\",\n    value: function getSouthWest() {\n      return this._sw;\n    }\n  }, {\n    key: \"getNorthEast\",\n    value: function getNorthEast() {\n      return this._ne;\n    }\n  }, {\n    key: \"getNorthWest\",\n    value: function getNorthWest() {\n      return new LngLat(this.getWest(), this.getNorth());\n    }\n  }, {\n    key: \"getSouthEast\",\n    value: function getSouthEast() {\n      return new LngLat(this.getEast(), this.getSouth());\n    }\n  }, {\n    key: \"getWest\",\n    value: function getWest() {\n      return this._sw.lng;\n    }\n  }, {\n    key: \"getSouth\",\n    value: function getSouth() {\n      return this._sw.lat;\n    }\n  }, {\n    key: \"getEast\",\n    value: function getEast() {\n      return this._ne.lng;\n    }\n  }, {\n    key: \"getNorth\",\n    value: function getNorth() {\n      return this._ne.lat;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this._sw.toArray(), this._ne.toArray()];\n    }\n  }, {\n    key: \"toFlatArray\",\n    value: function toFlatArray() {\n      return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"LngLatBounds(\".concat(this._sw.toString(), \", \").concat(this._ne.toString(), \")\");\n    }\n  }], [{\n    key: \"convert\",\n    value: function convert(input) {\n      if (!input) {\n        throw new Error(\"Invalid LngLatBounds convert value: falsy\");\n      }\n\n      if (input instanceof LngLatBounds) {\n        return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n      }\n\n      if (Array.isArray(input) && input.length === 2) {\n        return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));\n      }\n\n      if (Array.isArray(input) && input.length === 4) {\n        return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));\n      }\n\n      throw new Error(\"`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]\");\n    }\n  }]);\n\n  return LngLatBounds;\n}(); // src/utils/uuid.ts\n\n\nfunction generateUUID() {\n  var randomString = Math.random().toString(16) + Date.now().toString(16) + Math.random().toString(16);\n  var uuidString = randomString.replace(/\\./g, \"\");\n  var uuid = [uuidString.slice(0, 8), uuidString.slice(8, 12), \"4\" + uuidString.slice(12, 15) + \"-8\" + uuidString.slice(15, 18), uuidString.slice(18, 30)].join(\"-\");\n  return uuid;\n} // src/SessionToken.ts\n\n\nvar SessionToken = /*#__PURE__*/function () {\n  function SessionToken(id) {\n    _classCallCheck(this, SessionToken);\n\n    this.id = id != null ? id : generateUUID();\n  }\n\n  _createClass(SessionToken, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.id;\n    }\n  }], [{\n    key: \"convert\",\n    value: function convert(token) {\n      return new SessionToken(token instanceof SessionToken ? token.id : token.toString());\n    }\n  }]);\n\n  return SessionToken;\n}(); // src/MapboxError.ts\n\n\nvar UNKNOWN_ERROR = \"Unknown error\";\n\nvar MapboxError = /*#__PURE__*/function (_Error) {\n  _inherits(MapboxError, _Error);\n\n  var _super = _createSuper(MapboxError);\n\n  function MapboxError(json, statusCode) {\n    var _this;\n\n    _classCallCheck(this, MapboxError);\n\n    _this = _super.call(this, String(json.message || json.error || UNKNOWN_ERROR));\n    _this.name = \"MapboxError\";\n    _this.statusCode = statusCode;\n    return _this;\n  }\n\n  _createClass(MapboxError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \" (\").concat(this.statusCode, \"): \").concat(this.message);\n    }\n  }]);\n\n  return MapboxError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction handleNonOkRes(res) {\n  return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var json;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (res.ok) {\n              _context.next = 5;\n              break;\n            }\n\n            _context.next = 3;\n            return res.json();\n\n          case 3:\n            json = _context.sent;\n            throw new MapboxError(json, res.status);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n} // src/fetch.ts\n\n\nvar _fetchImpl = globalThis.fetch;\nvar _abortControllerImpl = globalThis.AbortController;\n\nfunction polyfillFetch(_ref) {\n  var fetch = _ref.fetch,\n      AbortController = _ref.AbortController;\n  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!fetch) {\n    throw new Error(\"Fetch implementation must include implementations of `fetch`.\");\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\nfunction getFetch() {\n  if (!_fetchImpl) {\n    throw new Error(\"Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.\");\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n} // src/utils/queryParams.ts\n\n\nfunction queryParams() {\n  var params = [];\n\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  for (var _i = 0, _objects = objects; _i < _objects.length; _i++) {\n    var obj = _objects[_i];\n    if (!obj) continue;\n    var entries = Object.entries(obj);\n\n    for (var _i2 = 0, _entries = entries; _i2 < _entries.length; _i2++) {\n      var _entries$_i = _slicedToArray(_entries[_i2], 2),\n          key = _entries$_i[0],\n          value = _entries$_i[1];\n\n      if (value == null) continue;\n      params.push(\"\".concat(key, \"=\").concat(encodeURIComponent(String(value))));\n    }\n  }\n\n  return params.join(\"&\");\n} // src/search/MapboxSearch.ts\n\n\nvar _getQueryParams, getQueryParams_fn, _getFetchInfo, getFetchInfo_fn;\n\nvar _MapboxSearch = /*#__PURE__*/function () {\n  function _MapboxSearch() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, _MapboxSearch);\n\n    __privateAdd(this, _getQueryParams);\n\n    __privateAdd(this, _getFetchInfo);\n\n    var _a = options,\n        accessToken = _a.accessToken,\n        defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxSearch.defaults), defaults);\n  }\n\n  _createClass(_MapboxSearch, [{\n    key: \"suggest\",\n    value: function suggest(searchText, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var sessionToken, signal, options, url, _getFetch, fetch, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (searchText) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"searchText is required\");\n\n              case 2:\n                sessionToken = optionsArg.sessionToken, signal = optionsArg.signal;\n                options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n                  sessionToken: sessionToken\n                });\n\n                if (!(options.eta_type && (!options.origin || !options.navigation_profile))) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new Error(\"to provide eta estimate: eta, navigation_profile, and origin are required\");\n\n              case 6:\n                if (!(options.origin && !options.navigation_profile)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new Error(\"to provide distance estimate: both navigation_profile and origin are required\");\n\n              case 8:\n                url = new URL(\"\".concat(SUGGEST_URL, \"/\").concat(encodeURIComponent(searchText)));\n                url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n                _getFetch = getFetch(), fetch = _getFetch.fetch;\n                _context2.next = 13;\n                return fetch(url.toString(), {\n                  signal: signal\n                });\n\n              case 13:\n                res = _context2.sent;\n                _context2.next = 16;\n                return handleNonOkRes(res);\n\n              case 16:\n                _context2.next = 18;\n                return res.json();\n\n              case 18:\n                json = _context2.sent;\n                return _context2.abrupt(\"return\", json);\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(suggestion, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var sessionTokenLike, signal, sessionToken, url, _getFetch2, fetch, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (suggestion) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error(\"suggestion is required\");\n\n              case 2:\n                if (this.canRetrieve(suggestion)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                throw new Error(\"suggestion cannot be retrieved\");\n\n              case 4:\n                sessionTokenLike = optionsArg.sessionToken, signal = optionsArg.signal;\n                sessionToken = SessionToken.convert(sessionTokenLike);\n                url = new URL(RETRIEVE_URL);\n                url.search = queryParams({\n                  access_token: this.accessToken,\n                  session_token: sessionToken.id\n                });\n                _getFetch2 = getFetch(), fetch = _getFetch2.fetch;\n                _context3.next = 11;\n                return fetch(url.toString(), __spreadProps(__spreadValues({}, __privateMethod(this, _getFetchInfo, getFetchInfo_fn).call(this, suggestion)), {\n                  signal: signal\n                }));\n\n              case 11:\n                res = _context3.sent;\n                _context3.next = 14;\n                return handleNonOkRes(res);\n\n              case 14:\n                _context3.next = 16;\n                return res.json();\n\n              case 16:\n                json = _context3.sent;\n                return _context3.abrupt(\"return\", json);\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"canRetrieve\",\n    value: function canRetrieve(suggestion) {\n      var action = suggestion.action;\n\n      if (!action) {\n        return false;\n      }\n\n      return action.method === \"POST\" && action.endpoint === ENDPOINT_RETRIEVE;\n    }\n  }, {\n    key: \"canSuggest\",\n    value: function canSuggest(suggestion) {\n      var action = suggestion.action;\n\n      if (!action) {\n        return false;\n      }\n\n      return action.method === \"POST\" && action.endpoint === ENDPOINT_SUGGEST;\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(_0) {\n      return __async(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(searchText) {\n        var optionsArg,\n            options,\n            baseUrl,\n            url,\n            _getFetch3,\n            fetch,\n            res,\n            json,\n            _args4 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                optionsArg = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n\n                if (searchText) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"searchText is required\");\n\n              case 3:\n                options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n                baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n                url = new URL(\"\".concat(baseUrl, \"/\").concat(encodeURIComponent(searchText)));\n                url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n                _getFetch3 = getFetch(), fetch = _getFetch3.fetch;\n                _context4.next = 10;\n                return fetch(url.toString(), {\n                  signal: options.signal\n                });\n\n              case 10:\n                res = _context4.sent;\n                _context4.next = 13;\n                return handleNonOkRes(res);\n\n              case 13:\n                _context4.next = 15;\n                return res.json();\n\n              case 15:\n                json = _context4.sent;\n                return _context4.abrupt(\"return\", json);\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(_0) {\n      return __async(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(lngLat) {\n        var optionsArg,\n            options,\n            searchText,\n            baseUrl,\n            url,\n            _getFetch4,\n            fetch,\n            res,\n            json,\n            _args5 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                optionsArg = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n\n                if (lngLat) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new Error(\"lngLat is required\");\n\n              case 3:\n                options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n                searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n                baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n                url = new URL(\"\".concat(baseUrl, \"/\").concat(encodeURIComponent(searchText)));\n                url.search = queryParams({\n                  access_token: this.accessToken,\n                  language: options.language,\n                  limit: options.limit\n                }, options.types && {\n                  types: typeof options.types === \"string\" ? options.types : _toConsumableArray(options.types).join(\",\")\n                });\n                _getFetch4 = getFetch(), fetch = _getFetch4.fetch;\n                _context5.next = 11;\n                return fetch(url.toString(), {\n                  signal: options.signal\n                });\n\n              case 11:\n                res = _context5.sent;\n                _context5.next = 14;\n                return handleNonOkRes(res);\n\n              case 14:\n                _context5.next = 16;\n                return res.json();\n\n              case 16:\n                json = _context5.sent;\n                return _context5.abrupt(\"return\", json);\n\n              case 18:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }]);\n\n  return _MapboxSearch;\n}();\n\nvar MapboxSearch = _MapboxSearch;\n_getQueryParams = new WeakSet();\n\ngetQueryParams_fn = function getQueryParams_fn(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    navigation_profile: options.navigation_profile,\n    eta_type: options.eta_type\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.origin && {\n    origin: typeof options.origin === \"string\" ? options.origin : LngLat.convert(options.origin).toArray().join(\",\")\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : _toConsumableArray(options.types).join(\",\")\n  });\n};\n\n_getFetchInfo = new WeakSet();\n\ngetFetchInfo_fn = function getFetchInfo_fn(suggestion) {\n  if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n    throw new Error(\"Suggestion cannot be retrieved or suggested\");\n  }\n\n  var action = suggestion.action;\n  var body = JSON.stringify(action.body);\n  return {\n    method: action.method,\n    body: body,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Content-Length\": body.length.toString()\n    }\n  };\n};\n\nMapboxSearch.defaults = {\n  language: \"en\"\n}; // src/autofill/constants.ts\n\nvar SEARCH_URL2 = \"https://api.mapbox.com/autofill/v1\";\nvar ENDPOINT_SUGGEST2 = \"suggest\";\nvar ENDPOINT_RETRIEVE2 = \"retrieve\";\nvar SUGGEST_URL2 = \"\".concat(SEARCH_URL2, \"/\").concat(ENDPOINT_SUGGEST2);\nvar RETRIEVE_URL2 = \"\".concat(SEARCH_URL2, \"/\").concat(ENDPOINT_RETRIEVE2); // src/autofill/MapboxAutofill.ts\n\nvar _getQueryParams2, getQueryParams_fn2;\n\nvar _MapboxAutofill = /*#__PURE__*/function () {\n  function _MapboxAutofill() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, _MapboxAutofill);\n\n    __privateAdd(this, _getQueryParams2);\n\n    var _a = options,\n        accessToken = _a.accessToken,\n        defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxAutofill.defaults), defaults);\n  }\n\n  _createClass(_MapboxAutofill, [{\n    key: \"suggest\",\n    value: function suggest(searchText, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var sessionToken, signal, options, url, _getFetch5, fetch, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (searchText) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error(\"searchText is required\");\n\n              case 2:\n                sessionToken = optionsArg.sessionToken, signal = optionsArg.signal;\n                options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n                  sessionToken: sessionToken\n                });\n                url = new URL(\"\".concat(SUGGEST_URL2, \"/\").concat(encodeURIComponent(searchText)));\n                url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n                _getFetch5 = getFetch(), fetch = _getFetch5.fetch;\n                _context6.next = 9;\n                return fetch(url.toString(), {\n                  signal: signal\n                });\n\n              case 9:\n                res = _context6.sent;\n                _context6.next = 12;\n                return handleNonOkRes(res);\n\n              case 12:\n                _context6.next = 14;\n                return res.json();\n\n              case 14:\n                json = _context6.sent;\n                return _context6.abrupt(\"return\", __spreadProps(__spreadValues({}, json), {\n                  suggestions: json.suggestions.map(function (suggestion) {\n                    return __spreadProps(__spreadValues({}, suggestion), {\n                      original_search_text: searchText\n                    });\n                  })\n                }));\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(suggestion, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var sessionTokenLike, signal, sessionToken, url, _getFetch6, fetch, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (suggestion) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error(\"suggestion is required\");\n\n              case 2:\n                if (this.canRetrieve(suggestion)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new Error(\"suggestion cannot be retrieved\");\n\n              case 4:\n                sessionTokenLike = optionsArg.sessionToken, signal = optionsArg.signal;\n                sessionToken = SessionToken.convert(sessionTokenLike);\n                url = new URL(\"\".concat(RETRIEVE_URL2, \"/\").concat(suggestion.action.id));\n                url.search = queryParams({\n                  access_token: this.accessToken,\n                  session_token: sessionToken.id\n                });\n                _getFetch6 = getFetch(), fetch = _getFetch6.fetch;\n                _context7.next = 11;\n                return fetch(url.toString(), {\n                  signal: signal\n                });\n\n              case 11:\n                res = _context7.sent;\n                _context7.next = 14;\n                return handleNonOkRes(res);\n\n              case 14:\n                _context7.next = 16;\n                return res.json();\n\n              case 16:\n                json = _context7.sent;\n                return _context7.abrupt(\"return\", json);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"canRetrieve\",\n    value: function canRetrieve(suggestion) {\n      var action = suggestion.action;\n      return typeof (action == null ? void 0 : action.id) === \"string\";\n    }\n  }]);\n\n  return _MapboxAutofill;\n}();\n\nvar MapboxAutofill = _MapboxAutofill;\n_getQueryParams2 = new WeakSet();\n\ngetQueryParams_fn2 = function getQueryParams_fn2(options) {\n  return queryParams({\n    types: \"address\",\n    streets: true,\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\n\nMapboxAutofill.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n}; // src/validate/constants.ts\n\nvar SEARCH_URL3 = \"https://api.mapbox.com/autofill/v1\";\nvar ENDPOINT_VALIDATE = \"retrieve\";\nvar VALIDATE_URL = \"\".concat(SEARCH_URL3, \"/\").concat(ENDPOINT_VALIDATE); // src/validate/MapboxValidate.ts\n\nvar _getQueryParams3, getQueryParams_fn3;\n\nvar _MapboxValidate = /*#__PURE__*/function () {\n  function _MapboxValidate() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, _MapboxValidate);\n\n    __privateAdd(this, _getQueryParams3);\n\n    var _a = options,\n        accessToken = _a.accessToken,\n        defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxValidate.defaults), defaults);\n  }\n\n  _createClass(_MapboxValidate, [{\n    key: \"validate\",\n    value: function validate(searchText, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var sessionToken, signal, options, url, _getFetch7, fetch, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (searchText) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new Error(\"searchText is required\");\n\n              case 2:\n                sessionToken = optionsArg.sessionToken, signal = optionsArg.signal;\n                options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n                  sessionToken: sessionToken\n                });\n                url = new URL(\"\".concat(VALIDATE_URL, \"/\").concat(encodeURIComponent(searchText)));\n                url.search = __privateMethod(this, _getQueryParams3, getQueryParams_fn3).call(this, options);\n                _getFetch7 = getFetch(), fetch = _getFetch7.fetch;\n                _context8.next = 9;\n                return fetch(url.toString(), {\n                  signal: signal\n                });\n\n              case 9:\n                res = _context8.sent;\n                _context8.next = 12;\n                return handleNonOkRes(res);\n\n              case 12:\n                _context8.next = 14;\n                return res.json();\n\n              case 14:\n                json = _context8.sent;\n\n                if (json.features.length > 0) {\n                  json.features = [json.features[0]];\n                }\n\n                return _context8.abrupt(\"return\", json);\n\n              case 17:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }]);\n\n  return _MapboxValidate;\n}();\n\nvar MapboxValidate = _MapboxValidate;\n_getQueryParams3 = new WeakSet();\n\ngetQueryParams_fn3 = function getQueryParams_fn3(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\n\nMapboxValidate.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n}; // src/geocode/constants.ts\n\nvar SEARCH_URL4 = \"https://api.mapbox.com/geocoding/v5\";\nvar TEMP_URL = \"\".concat(SEARCH_URL4, \"/mapbox.places\");\nvar PERMANENT_URL = \"\".concat(SEARCH_URL4, \"/mapbox.places-permanent\"); // src/geocode/MapboxGeocode.ts\n\nvar _getQueryParams4, getQueryParams_fn4;\n\nvar MapboxGeocode = /*#__PURE__*/function () {\n  function MapboxGeocode() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MapboxGeocode);\n\n    __privateAdd(this, _getQueryParams4);\n\n    var _a = options,\n        accessToken = _a.accessToken,\n        defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues({}, defaults);\n  }\n\n  _createClass(MapboxGeocode, [{\n    key: \"forward\",\n    value: function forward(searchText, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var signal, options, baseUrl, url, _getFetch8, fetch, fetchInit, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (searchText) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error(\"searchText is required\");\n\n              case 2:\n                if (optionsArg) {\n                  signal = optionsArg.signal;\n                }\n\n                options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n                baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n                url = new URL(\"\".concat(baseUrl, \"/\").concat(encodeURIComponent(searchText), \".json\"));\n                url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options);\n                _getFetch8 = getFetch(), fetch = _getFetch8.fetch;\n                fetchInit = signal ? {\n                  signal: signal\n                } : {};\n                _context9.next = 11;\n                return fetch(url.toString(), fetchInit);\n\n              case 11:\n                res = _context9.sent;\n                _context9.next = 14;\n                return handleNonOkRes(res);\n\n              case 14:\n                _context9.next = 16;\n                return res.json();\n\n              case 16:\n                json = _context9.sent;\n                return _context9.abrupt(\"return\", json);\n\n              case 18:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(lngLat, optionsArg) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var signal, options, searchText, baseUrl, url, _getFetch9, fetch, fetchInit, res, json;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (lngLat) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error(\"lngLat is required\");\n\n              case 2:\n                if (optionsArg) {\n                  signal = optionsArg.signal;\n                }\n\n                options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n                searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n                baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n                url = new URL(\"\".concat(baseUrl, \"/\").concat(encodeURIComponent(searchText), \".json\"));\n                url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options, true);\n                _getFetch9 = getFetch(), fetch = _getFetch9.fetch;\n                fetchInit = signal ? {\n                  signal: signal\n                } : {};\n                _context10.next = 12;\n                return fetch(url.toString(), fetchInit);\n\n              case 12:\n                res = _context10.sent;\n                _context10.next = 15;\n                return handleNonOkRes(res);\n\n              case 15:\n                _context10.next = 17;\n                return res.json();\n\n              case 17:\n                json = _context10.sent;\n                return _context10.abrupt(\"return\", json);\n\n              case 19:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }]);\n\n  return MapboxGeocode;\n}();\n\n_getQueryParams4 = new WeakSet();\n\ngetQueryParams_fn4 = function getQueryParams_fn4(options) {\n  var isReverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (isReverse) {\n    [\"proximity\", \"autocomplete\", \"fuzzyMatch\", \"bbox\"].forEach(function (key) {\n      if (key in options) {\n        delete options[key];\n      }\n    });\n  }\n\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    autocomplete: options.autocomplete,\n    fuzzyMatch: options.fuzzyMatch,\n    routing: options.routing,\n    worldview: options.worldview\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : _toConsumableArray(options.types).join(\",\")\n  });\n}; // src/types.ts\n\n\nvar MatchCodeConfidence = /* @__PURE__ */function (MatchCodeConfidence2) {\n  MatchCodeConfidence2[\"exact\"] = \"exact\";\n  MatchCodeConfidence2[\"high\"] = \"high\";\n  MatchCodeConfidence2[\"medium\"] = \"medium\";\n  MatchCodeConfidence2[\"low\"] = \"low\";\n  return MatchCodeConfidence2;\n}(MatchCodeConfidence || {}); // src/utils/Evented.ts\n\n\nvar _listeners;\n\nvar Evented = /*#__PURE__*/function () {\n  function Evented() {\n    _classCallCheck(this, Evented);\n\n    __privateAdd(this, _listeners, {});\n  }\n\n  _createClass(Evented, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener) {\n      var listenersArr = __privateGet(this, _listeners);\n\n      if (!listenersArr[type]) {\n        listenersArr[type] = [];\n      }\n\n      listenersArr[type].push(listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, listener) {\n      var listenersArr = __privateGet(this, _listeners);\n\n      if (!listenersArr[type]) {\n        return;\n      }\n\n      var listeners = listenersArr[type];\n      var index = listeners.indexOf(listener);\n\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(type, arg0) {\n      var listenersArr = __privateGet(this, _listeners);\n\n      if (!listenersArr[type]) {\n        return;\n      }\n\n      var listeners = listenersArr[type];\n\n      var _iterator3 = _createForOfIteratorHelper(listeners),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var listener = _step3.value;\n          listener(arg0);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }]);\n\n  return Evented;\n}();\n\n_listeners = new WeakMap(); // src/utils/debounce.ts\n\nfunction debounce(func, wait, signalFn) {\n  var timeout = null;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    var signal = signalFn && signalFn();\n    timeout = setTimeout(function () {\n      timeout = null;\n\n      if (signal == null ? void 0 : signal.aborted) {\n        return;\n      }\n\n      func.apply(void 0, args);\n    }, wait);\n  };\n} // src/SearchSession.ts\n\n\nfunction createAbortController() {\n  var _getFetch10 = getFetch(),\n      AbortController = _getFetch10.AbortController;\n\n  return new AbortController();\n}\n\nvar _suggestions, _abort, _suggestDebounce;\n\nvar SearchSession = /*#__PURE__*/function (_Evented) {\n  _inherits(SearchSession, _Evented);\n\n  var _super2 = _createSuper(SearchSession);\n\n  function SearchSession(search) {\n    var _this2;\n\n    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, SearchSession);\n\n    _this2 = _super2.call(this);\n    _this2.sessionToken = new SessionToken();\n\n    __privateAdd(_assertThisInitialized(_this2), _suggestions, void 0);\n\n    __privateAdd(_assertThisInitialized(_this2), _abort, createAbortController());\n\n    __privateAdd(_assertThisInitialized(_this2), _suggestDebounce, void 0);\n\n    __privateSet(_assertThisInitialized(_this2), _suggestDebounce, debounce(function (_0) {\n      for (var _len3 = arguments.length, _1 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        _1[_key3 - 1] = arguments[_key3];\n      }\n\n      return __async(_assertThisInitialized(_this2), [_0].concat(_1), /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(searchText) {\n        var options,\n            res,\n            _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n\n                __privateGet(this, _abort).abort();\n\n                __privateSet(this, _abort, createAbortController());\n\n                if (searchText) {\n                  _context11.next = 7;\n                  break;\n                }\n\n                __privateSet(this, _suggestions, null);\n\n                this.fire(\"suggest\", __privateGet(this, _suggestions));\n                return _context11.abrupt(\"return\");\n\n              case 7:\n                _context11.prev = 7;\n                _context11.next = 10;\n                return this.search.suggest(searchText, __spreadProps(__spreadValues({\n                  sessionToken: this.sessionToken\n                }, options), {\n                  signal: __privateGet(this, _abort).signal\n                }));\n\n              case 10:\n                res = _context11.sent;\n\n                __privateSet(this, _suggestions, res);\n\n                this.fire(\"suggest\", res);\n                _context11.next = 20;\n                break;\n\n              case 15:\n                _context11.prev = 15;\n                _context11.t0 = _context11[\"catch\"](7);\n\n                if (!(_context11.t0.name === \"AbortError\")) {\n                  _context11.next = 19;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\");\n\n              case 19:\n                this.fire(\"suggesterror\", _context11.t0);\n\n              case 20:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[7, 15]]);\n      }));\n    }, wait, function () {\n      return __privateGet(_assertThisInitialized(_this2), _abort).signal;\n    }));\n\n    Object.defineProperties(_assertThisInitialized(_this2), {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n    return _this2;\n  }\n\n  _createClass(SearchSession, [{\n    key: \"suggestions\",\n    get: function get() {\n      return __privateGet(this, _suggestions);\n    }\n  }, {\n    key: \"suggest\",\n    value: function suggest(searchText, options) {\n      var _this3 = this;\n\n      __privateGet(this, _suggestDebounce).call(this, searchText, options);\n\n      return new Promise(function (resolve, reject) {\n        var _suggestFn;\n\n        var _suggestErrorFn;\n\n        _suggestFn = function suggestFn(res) {\n          _this3.removeEventListener(\"suggest\", _suggestFn);\n\n          _this3.removeEventListener(\"suggesterror\", _suggestErrorFn);\n\n          resolve(res);\n        };\n\n        _suggestErrorFn = function suggestErrorFn(err) {\n          _this3.removeEventListener(\"suggest\", _suggestFn);\n\n          _this3.removeEventListener(\"suggesterror\", _suggestErrorFn);\n\n          reject(err);\n        };\n\n        _this3.addEventListener(\"suggest\", _suggestFn);\n\n        _this3.addEventListener(\"suggesterror\", _suggestErrorFn);\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.suggest(\"\");\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(suggestion, options) {\n      return __async(this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.search.retrieve(suggestion, __spreadValues({\n                  sessionToken: this.sessionToken\n                }, options));\n\n              case 2:\n                res = _context12.sent;\n                this.fire(\"retrieve\", res);\n                return _context12.abrupt(\"return\", res);\n\n              case 5:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"canRetrieve\",\n    value: function canRetrieve(suggestion) {\n      if (!this.search.canRetrieve) {\n        return true;\n      }\n\n      return this.search.canRetrieve(suggestion);\n    }\n  }, {\n    key: \"canSuggest\",\n    value: function canSuggest(suggestion) {\n      if (!this.search.canSuggest) {\n        return true;\n      }\n\n      return this.search.canSuggest(suggestion);\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      __privateGet(this, _abort).abort();\n\n      __privateSet(this, _abort, createAbortController());\n    }\n  }]);\n\n  return SearchSession;\n}(Evented);\n\n_suggestions = new WeakMap();\n_abort = new WeakMap();\n_suggestDebounce = new WeakMap(); // src/featureToSuggestion.ts\n\nfunction featureToSuggestion(feature) {\n  var properties = feature.properties;\n  return __spreadValues({}, properties);\n}\n\nexport { Evented, LngLat, LngLatBounds, MapboxAutofill, MapboxError, MapboxGeocode, MapboxSearch, MapboxValidate, MatchCodeConfidence, SearchSession, SessionToken, debounce, featureToSuggestion, polyfillFetch };","map":{"version":3,"mappings":"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","names":["SEARCH_URL","ENDPOINT_SUGGEST","ENDPOINT_RETRIEVE","ENDPOINT_FORWARD","ENDPOINT_REVERSE","SUGGEST_URL","RETRIEVE_URL","FORWARD_URL","PERMANENT_FORWARD_URL","REVERSE_URL","PERMANENT_REVERSE_URL","lng","lat","isNaN","Error","input","LngLat","Array","isArray","length","Number","lon","sw","ne","_sw","convert","_ne","getWest","getNorth","getEast","getSouth","toArray","toString","LngLatBounds","getSouthWest","getNorthEast","randomString","Math","random","Date","now","uuidString","replace","uuid","slice","join","id","generateUUID","token","SessionToken","UNKNOWN_ERROR","json","statusCode","String","message","error","name","res","ok","MapboxError","status","_fetchImpl","globalThis","fetch","_abortControllerImpl","AbortController","force","params","objects","obj","entries","Object","key","value","push","encodeURIComponent","options","__privateAdd","accessToken","defaults","__objRest","_a","__spreadValues","_MapboxSearch","searchText","optionsArg","sessionToken","signal","__spreadProps","eta_type","origin","navigation_profile","url","URL","search","__privateMethod","_getQueryParams","getQueryParams_fn","getFetch","handleNonOkRes","suggestion","canRetrieve","sessionTokenLike","queryParams","access_token","session_token","_getFetchInfo","getFetchInfo_fn","action","method","endpoint","_0","baseUrl","permanent","lngLat","language","limit","types","country","proximity","bbox","toFlatArray","canSuggest","body","JSON","stringify","headers","MapboxSearch","SEARCH_URL2","ENDPOINT_SUGGEST2","ENDPOINT_RETRIEVE2","SUGGEST_URL2","RETRIEVE_URL2","_MapboxAutofill","_getQueryParams2","getQueryParams_fn2","suggestions","map","original_search_text","streets","MapboxAutofill","SEARCH_URL3","ENDPOINT_VALIDATE","VALIDATE_URL","_MapboxValidate","_getQueryParams3","getQueryParams_fn3","features","MapboxValidate","SEARCH_URL4","TEMP_URL","PERMANENT_URL","_getQueryParams4","getQueryParams_fn4","fetchInit","isReverse","forEach","autocomplete","fuzzyMatch","routing","worldview","MatchCodeConfidence","MatchCodeConfidence2","type","listener","listenersArr","__privateGet","_listeners","listeners","index","indexOf","splice","arg0","func","wait","signalFn","timeout","args","clearTimeout","setTimeout","aborted","createAbortController","__privateSet","_suggestDebounce","debounce","_1","__async","_abort","abort","_suggestions","fire","suggest","defineProperties","writable","Promise","resolve","reject","suggestFn","suggestErrorFn","removeEventListener","err","addEventListener","retrieve","Evented","feature","properties"],"sources":["/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/search/constants.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/LngLat.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/LngLatBounds.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/utils/uuid.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/SessionToken.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/MapboxError.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/fetch.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/utils/queryParams.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/search/MapboxSearch.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/autofill/constants.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/autofill/MapboxAutofill.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/validate/constants.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/validate/MapboxValidate.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/geocode/constants.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/geocode/MapboxGeocode.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/types.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/utils/Evented.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/utils/debounce.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/SearchSession.ts","/Users/akshayrajendraprasad/Downloads/Bedbugzbgone-1b773fb25e3250addc52927234b8e04bf7d3be81/bedbugzgone/node_modules/@mapbox/search-js-core/src/featureToSuggestion.ts"],"sourcesContent":["export const SEARCH_URL = `https://api.mapbox.com/search/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\nexport const ENDPOINT_FORWARD = 'forward';\nexport const ENDPOINT_REVERSE = 'reverse';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\nexport const FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nexport const PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\n\nexport const REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nexport const PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;\n","/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n * These coordinates use longitude, latitude coordinate order (as opposed to latitude, longitude)\n * to match the [GeoJSON specification](https://datatracker.ietf.org/doc/html/rfc7946#section-4),\n * which is equivalent to the OGC:CRS84 coordinate reference system.\n *\n * Note that any method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @class LngLat\n * @param lng - Longitude, measured in degrees.\n * @param lat - Latitude, measured in degrees.\n * @example\n * ```typescript\n * const ll = new LngLat(-123.9749, 40.7736);\n * console.log(ll.lng); // = -123.9749\n * ```\n */\nexport class LngLat {\n  /**\n   * @name lng\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lng: number;\n  /**\n   * @name lat\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lat: number;\n\n  constructor(lng: number, lat: number) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\n        'Invalid LngLat latitude value: must be between -90 and 90'\n      );\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\n        'Invalid LngLat longitude value: must be between -180 and 180'\n      );\n    }\n  }\n\n  /**\n   * Returns the coordinates represented as an array of two numbers.\n   *\n   * @returns The coordinates represeted as an array of longitude and latitude.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toArray(); // = [-73.9749, 40.7736]\n   * ```\n   */\n  toArray(): [number, number] {\n    return [this.lng, this.lat];\n  }\n\n  /**\n   * Returns the coordinates represent as a string.\n   *\n   * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n   * ```\n   */\n  toString(): string {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  /**\n   * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n   * to a `LngLat` object.\n   *\n   * If a `LngLat` object is passed in, the function returns a copy.\n   *\n   * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.\n   * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n   * @example\n   * ```typescript\n   * const arr = [-73.9749, 40.7736];\n   * const ll = LngLat.convert(arr);\n   * console.log(ll);   // = LngLat {lng: -73.9749, lat: 40.7736}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLat\n      | { lng: number; lat: number }\n      | { lon: number; lat: number }\n      | [number, number]\n  ): LngLat {\n    // Make a copy if already an LngLat.\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (\n      !Array.isArray(input) &&\n      typeof input == 'object' &&\n      input !== null &&\n      ('lng' in input || 'lon' in input) &&\n      'lat' in input\n    ) {\n      return new LngLat(\n        Number('lng' in input ? input.lng : input.lon),\n        Number(input.lat)\n      );\n    }\n\n    throw new Error(\n      '`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef LngLatLike\n * @type {LngLat | [number, number] | { lng: number, lat: number } | { lon: number, lat: number }}\n * @example\n * ```typescript\n * const v1 = new LngLat(-122.420679, 37.772537);\n * const v2 = [-122.420679, 37.772537];\n * const v3 = {lon: -122.420679, lat: 37.772537};\n * ```\n */\nexport type LngLatLike =\n  | LngLat\n  | { lng: number; lat: number }\n  | { lon: number; lat: number }\n  | [number, number];\n","import { LngLat, LngLatLike } from './LngLat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * Note that any method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @class LngLatBounds\n */\nexport class LngLatBounds {\n  private _ne: LngLat;\n  private _sw: LngLat;\n\n  /**\n   * @param sw - The southwest corner of the bounding box.\n   * @param ne - The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const sw = new LngLat(-73.9876, 40.7661);\n   * const ne = new LngLat(-73.9397, 40.8002);\n   * const llb = new LngLatBounds(sw, ne);\n   * ```\n   */\n  constructor(sw: LngLatLike, ne: LngLatLike) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  /**\n   * Returns the southwest corner of the bounding box.\n   *\n   * @returns The southwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthWest(); // LngLat {lng: -73.9876, lat: 40.7661}\n   * ```\n   */\n  getSouthWest(): LngLat {\n    return this._sw;\n  }\n\n  /**\n   * Returns the northeast corner of the bounding box.\n   *\n   * @returns The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthEast(); // LngLat {lng: -73.9397, lat: 40.8002}\n   * ```\n   */\n  getNorthEast(): LngLat {\n    return this._ne;\n  }\n\n  /**\n   * Returns the northwest corner of the bounding box. This is commonly used\n   * as the 'min' point in the bounding box.\n   *\n   * @returns The northwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthWest(); // LngLat {lng: -73.9876, lat: 40.8002}\n   * ```\n   */\n  getNorthWest(): LngLat {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  /**\n   * Returns the southeast corner of the bounding box. This is commonly used\n   * as the 'max' point in the bounding box.\n   *\n   * @returns The southeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthEast(); // LngLat {lng: -73.9397, lat: 40.7661}\n   * ```\n   */\n  getSouthEast(): LngLat {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  /**\n   * Returns the west edge of the bounding box.\n   *\n   * @returns The west edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getWest(); // -73.9876\n   * ```\n   */\n  getWest(): number {\n    return this._sw.lng;\n  }\n\n  /**\n   * Returns the south edge of the bounding box.\n   *\n   * @returns The south edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouth(); // 40.7661\n   * ```\n   */\n  getSouth(): number {\n    return this._sw.lat;\n  }\n\n  /**\n   * Returns the east edge of the bounding box.\n   *\n   * @returns The east edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getEast(); // -73.9397\n   * ```\n   */\n  getEast(): number {\n    return this._ne.lng;\n  }\n\n  /**\n   * Returns the north edge of the bounding box.\n   *\n   * @returns The north edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorth(); // 40.8002\n   * ```\n   */\n  getNorth(): number {\n    return this._ne.lat;\n  }\n\n  /**\n   * Returns the bounding box represented as an array.\n   *\n   * @returns The bounding box represented as an array, consisting of the\n   *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n   * ```\n   */\n  toArray(): [[number, number], [number, number]] {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  /**\n   * Returns the bounding box represented as a flattened array.\n   *\n   * @returns The bounding box represented as an array of numbers in [west, south, east, north] order.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toFlatArray(); // = [-73.9876, 40.7661, -73.9397, 40.8002]\n   * ```\n   */\n  toFlatArray(): [number, number, number, number] {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  /**\n   * Return the bounding box represented as a string.\n   *\n   * @returns The bounding box represents as a string of the format\n   *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n   * ```\n   */\n  toString(): string {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  /**\n   * Converts an array to a `LngLatBounds` object.\n   *\n   * If a `LngLatBounds` object is passed in, the function returns a copy.\n   *\n   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n   *\n   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.\n   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n   * @example\n   * ```typescript\n   * const arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n   * const llb = LngLatBounds.convert(arr);\n   * console.log(llb);   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLatBounds\n      | [LngLatLike, LngLatLike]\n      | [number, number, number, number]\n  ): LngLatBounds {\n    if (!input) {\n      throw new Error('Invalid LngLatBounds convert value: falsy');\n    }\n\n    // Make a copy if already an LngLatBounds.\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(\n        LngLat.convert(input[0]),\n        LngLat.convert(input[1])\n      );\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(\n        LngLat.convert([input[0], input[1]]),\n        LngLat.convert([input[2], input[3]])\n      );\n    }\n\n    throw new Error(\n      '`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef LngLatBoundsLike\n * @type {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]}\n * @example\n * ```typescript\n * const v1 = new LngLatBounds(\n *   new LngLat(-73.9876, 40.7661),\n *   new LngLat(-73.9397, 40.8002)\n * );\n * const v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n * const v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n * ```\n */\nexport type LngLatBoundsLike =\n  | LngLatBounds\n  | [LngLatLike, LngLatLike]\n  | [number, number, number, number];\n","const UUID_RE =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Validates the UUID v4.\n * @param id - UUID value.\n */\nexport function validateUUID(id: string): boolean {\n  return UUID_RE.test(id);\n}\n\n/**\n * Generates a RFC4122 v4 UUID (pseudo-randomly-based)\n *\n * IMPORTANT: THIS IS NOT CRYPTO-GRAPHICALLY SECURE!\n *\n * Since we're using this to generate a random UUID, essentially as an SKU,\n * we don't need to worry about the randomness of the values as much.\n */\nexport function generateUUID(): string {\n  const randomString =\n    Math.random().toString(16) +\n    Date.now().toString(16) +\n    Math.random().toString(16);\n\n  const uuidString = randomString.replace(/\\./g, '');\n\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    '4' + uuidString.slice(12, 15) + '-8' + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join('-');\n\n  return uuid;\n}\n","import { generateUUID } from './utils/uuid';\n\n/**\n * A `SessionToken` object is a unique identifier that groups together `suggest` / `retrieve` calls as part of the\n * [Mapbox Search API](https://docs.mapbox.com/api/search/search/#retrieve-a-suggestion).\n *\n * Session tokens are used for [billing](https://docs.mapbox.com/api/search/search/#search-api-pricing) and\n * customer-accessible analytics.\n *\n * A [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value is recommended,\n * and is generated if an `id` is not provided.\n *\n * Note that any method that accepts a `SessionToken` object as an argument or option\n * can also accept a unique `string` and will perform an implicit conversion.\n * This flexible type is documented as {@link SessionTokenLike}.\n *\n * @name SessionToken\n * @example\n * ```typescript\n * const token = new SessionToken();\n * console.log(token.id); // = I am a UUIDv4 value!\n * ```\n */\nexport class SessionToken {\n  /**\n   * The session token in string format.\n   */\n  readonly id: string;\n\n  constructor(id?: string) {\n    this.id = id ?? generateUUID();\n  }\n\n  /**\n   * Returns the session token in string format.\n   *\n   * This is the same as calling `token.id`, and is okay to be used for serialization.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Converts a string to a `SessionToken` object.\n   *\n   * If a `SessionToken` object is passed in, the function returns a copy.\n   */\n  static convert(token: SessionToken | string): SessionToken {\n    return new SessionToken(\n      token instanceof SessionToken ? token.id : token.toString()\n    );\n  }\n}\n\n/**\n * A {@link SessionToken} object or string representing a Mapbox Search API session token.\n *\n * It's recommended this value is a [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value.\n *\n * @typedef SessionTokenLike\n * @type {SessionToken | string}\n * @example\n * const v1 = new SessionToken();\n * const v2 = new SessionToken('f06e7531-6373-4d5a-8614-b6f313488050');\n * const v3 = 'f06e7531-6373-4d5a-8614-b6f313488050';\n */\nexport type SessionTokenLike = string | SessionToken;\n","export const UNKNOWN_ERROR = 'Unknown error';\n\n/**\n * Thrown from Search JS Core functions when a network request fails.\n *\n * See common errors here:\n * - [MapboxSearch](https://docs.mapbox.com/api/search/search/#search-api-errors)\n * - [MapboxAutofill](https://docs.mapbox.com/api/search/geocoding/#geocoding-api-errors)\n */\nexport class MapboxError extends Error {\n  readonly statusCode: number;\n\n  constructor(json: Record<string, unknown>, statusCode: number) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = 'MapboxError';\n    this.statusCode = statusCode;\n  }\n\n  /**\n   * Modified Error toString() method to include the status code.\n   */\n  toString(): string {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n}\n\n/**\n * Utility function to see if the result is \"ok\" (in 200 range).\n *\n * If not, throw a {@link MapboxError} filled out by the\n * [JSON error format](https://docs.mapbox.com/api/search/search/#search-api-errors).\n */\nexport async function handleNonOkRes(res: Response): Promise<void> {\n  if (!res.ok) {\n    const json = await res.json();\n    throw new MapboxError(json, res.status);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// GLOBALS\nlet _fetchImpl: typeof fetch = globalThis.fetch;\nlet _abortControllerImpl: typeof AbortController = globalThis.AbortController;\n\ninterface FetchImplementation {\n  fetch: typeof fetch;\n  AbortController: typeof AbortController;\n}\n\n/**\n * Polyfills {@link fetch} implementation used in Search JS Core.\n *\n * If a `fetch` implementation is already available, the polyfill will be\n * silently ignored.\n *\n * When running Search JS Core in a Node.js environment, fetch must be either\n * polyfilled globally or passed into this function before usage of\n * internal library functionality.\n *\n * @param opts Options for the polyfill.\n * @param {fetch} opts.fetch Required. A custom `fetch` implementation.\n * @param {AbortController} opts.AbortController Required. A custom `AbortController` implementation.\n * @param {boolean} force If `true`, the polyfill will be forced to load. Otherwise, it will only load if `fetch` is not available.\n */\nexport function polyfillFetch(\n  { fetch, AbortController }: FetchImplementation,\n  force = false\n): void {\n  if (!fetch) {\n    throw new Error(\n      'Fetch implementation must include implementations of `fetch`.'\n    );\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\n/**\n * Returns the {@link FetchImplementation} used by Search JS Core.\n */\nexport function getFetch(): FetchImplementation {\n  if (!_fetchImpl) {\n    throw new Error(\n      'Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.'\n    );\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n","type Primitive = string | number | boolean | null;\n\n/**\n * tl;dr - [classnames](https://www.npmjs.com/package/classnames) for query parameters.\n *\n * Encodes query parameters into a stringified form, good for use with {@link URL#search}.\n * Objects are key-value pairs, and if a falsy object is passed, it will be omitted.\n *\n * Null and undefined values are ignored.\n * Array values are encoded as comma-separated values.\n *\n * @example\n * ```typescript\n * const limit = 0;\n * const offset = null;\n * const params = queryParams(\n *  {\n *    q: 'pizza',\n *    c: null\n *  },\n *  (limit != null) && { limit },\n *  (offset != null) && { offset }\n * );\n * console.log(params); // = 'q=pizza&limit=0'\n * ```\n */\nexport function queryParams<T extends Record<string, Primitive>>(\n  ...objects: (T | false)[]\n): string {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join('&');\n}\n","import {\n  ENDPOINT_RETRIEVE,\n  ENDPOINT_SUGGEST,\n  FORWARD_URL,\n  PERMANENT_FORWARD_URL,\n  PERMANENT_REVERSE_URL,\n  RETRIEVE_URL,\n  REVERSE_URL,\n  SUGGEST_URL\n} from './constants';\nimport {\n  AdministrativeUnitTypes,\n  Suggestion,\n  FeatureSuggestion\n} from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism works in the same way as the [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests\n   * together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef Options\n */\nexport interface Options {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * The navigation routing profile to use for distance/eta calculations.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  navigation_profile?: 'driving' | 'walking' | 'cycling';\n  /**\n   * The location from which to calculate distance. **This parameter may incur additional latency.**\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  origin: string | LngLatLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Used to estimate the time of arrival from {@link Options#origin}. **This parameter may incur additional latency.**\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  eta_type?: 'navigation';\n  /**\n   * Limit results to one or more types of features. If no types are specified, all possible types may be returned.\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#administrative-unit-types\n   */\n  types?: string | Set<AdministrativeUnitTypes>;\n}\n\ninterface PermanentOptions {\n  /**\n   * The permanent endpoints are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * @typedef SuggestionResponse\n */\nexport interface SuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: Suggestion[];\n}\n\n/**\n * @typedef RetrieveResponse\n */\nexport interface RetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: FeatureSuggestion[];\n}\n\n/**\n * A `MapboxSearch` object is an application's main entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/).\n *\n * `MapboxSearch` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxSearch#suggest}: The user enters a search term, and a list of suggested results is returned with\n *      optional data such as: eta, distance calculations, etc.\n *   2. {@link MapboxSearch#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned for displaying on a map or otherwise manipulating.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxSearch`, and\n * other options may be specified either in the constructor or in the {@link MapboxSearch#suggest} call.\n *\n * @class MapboxSearch\n * @param {Options} [options]\n * @param {string} [options.accessToken]\n *\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const sessionToken = new SessionToken();\n * const result = await search.suggest('Washington D.C.', { sessionToken });\n * if (result.suggestions.length === 0) return;\n *\n * const suggestion = result.suggestions[0];\n * if (search.canRetrieve(suggestion)) {\n *  const { features } = await search.retrieve(suggestion, { sessionToken });\n *  doSomethingWithCoordinates(features);\n * } else if (search.canSuggest(suggestion)) {\n *   // .. go through suggest flow again ..\n * }\n * ```\n */\nexport class MapboxSearch {\n  static defaults: Partial<Options> = {\n    language: 'en'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link Options}) to be merged into options in the following methods:\n   * - {@link MapboxSearch#suggest}\n   * - {@link MapboxSearch#forward}\n   * - {@link MapboxSearch#reverse}\n   */\n  defaults: Partial<Options>;\n\n  constructor(options: Partial<AccessTokenOptions & Options> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxSearch.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Interactive search} */\n\n  /**\n   * {@link MapboxSearch#suggest} is \"part one\" of the two-step interactive search experience, and includes\n   * useful information such as: {@link Suggestion#feature_name}, {@link Suggestion#description}, and {@link Suggestion#maki}.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * It may be useful to call {@link MapboxSearch#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link MapboxSearch#canSuggest}, and further calls to {@link MapboxSearch#suggest}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {string} searchText\n   * @param {Options} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & Options>\n  ): Promise<SuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n      throw new Error(\n        'to provide eta estimate: eta, navigation_profile, and origin are required'\n      );\n    }\n    if (options.origin && !options.navigation_profile) {\n      throw new Error(\n        'to provide distance estimate: both navigation_profile and origin are required'\n      );\n    }\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as SuggestionResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link MapboxSearch#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * feature suggestions should come from the {@link MapboxSearch#forward} method\n   * with {@link PermanentOptions#permanent} enabled.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {any} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<RetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(RETRIEVE_URL);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      ...this.#getFetchInfo(suggestion),\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  /** @section {Programmatic search} */\n\n  /**\n   * {@link MapboxSearch#forward} is our programmatic one-step search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async forward(\n    searchText: string,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#reverse} allows you to look up a geographic coordinate pair\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param lngLat - Either a {@link LngLatLike} object or string in 'lng,lat' comma-separated format.\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n\n    const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxSearch#suggest} and\n   * {@link MapboxSearch#forward}.\n   */\n  #getQueryParams(options: Partial<Options & SessionTokenOptions>): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        navigation_profile: options.navigation_profile,\n        eta_type: options.eta_type\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.origin && {\n        origin:\n          typeof options.origin === 'string'\n            ? options.origin\n            : LngLat.convert(options.origin).toArray().join(',')\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n\n  /**\n   * Gets a partial fetch request from this suggestion's action.\n   */\n  #getFetchInfo(suggestion: Suggestion): Partial<RequestInit> {\n    if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n      throw new Error('Suggestion cannot be retrieved or suggested');\n    }\n\n    const action = suggestion.action;\n    const body = JSON.stringify(action.body);\n\n    return {\n      method: action.method,\n      body,\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body.length.toString()\n      }\n    };\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n","import { RETRIEVE_URL, SUGGEST_URL } from './constants';\nimport { AutofillSuggestion, AutofillFeatureSuggestion } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef AutofillOptions\n */\nexport interface AutofillOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link AutofillOptions#proximity} and {@link AutofillOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef AutofillSuggestionResponse\n */\nexport interface AutofillSuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: AutofillSuggestion[];\n}\n\n/**\n * @typedef AutofillRetrieveResponse\n */\nexport interface AutofillRetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: AutofillFeatureSuggestion[];\n}\n\n/**\n * A `MapboxAutofill` object is an application's main entrypoint to the\n * Mapbox Autofill API. The Mapbox Autofill API is an API similar to {@link MapboxSearch},\n * but targeted towards **address** autocomplete.\n *\n * Only address types are returned by the API.\n *\n * `MapboxAutofill` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxAutofill#suggest}: The user enters a search term, and a list of suggested results is returned with\n *     address data.\n *   2. {@link MapboxAutofill#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxAutofill`, and\n * other options may be specified either in the constructor or in the {@link MapboxAutofill#suggest} call.\n *\n * @class MapboxAutofill\n * @param {AutofillOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxAutofill {\n  static defaults: Partial<AutofillOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link AutofillOptions}) to be merged into options in the following methods:\n   * - {@link MapboxAutofill#suggest}\n   *\n   * @type {AutofillOptions}\n   */\n  defaults: Partial<AutofillOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & AutofillOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxAutofill.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxAutofill#suggest} is \"part one\" of the two-step autofill experience, and includes\n   * autofill information.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & AutofillOptions>\n  ): Promise<AutofillSuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillSuggestionResponse;\n\n    // Add 'original_search_text' so we can retrieve.\n    return {\n      ...json,\n      suggestions: json.suggestions.map((suggestion) => {\n        return {\n          ...suggestion,\n          original_search_text: searchText\n        };\n      })\n    };\n  }\n\n  /**\n   * {@link MapboxAutofill#retrieve} is \"part two\" of the two-step autofill experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link AutofillSuggestion} returned from \"part one,\"\n   * {@link MapboxAutofill#suggest}.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: AutofillSuggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<AutofillRetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), { signal });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillRetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxAutofill#suggest}\n   */\n  #getQueryParams(\n    options: Partial<AutofillOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        types: 'address',\n        streets: true,\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n\n  /**\n   * Returns true if {@link MapboxAutofill#retrieve} can be called on this suggestion,\n   * false otherwise.\n   */\n  canRetrieve(suggestion: AutofillSuggestion): boolean {\n    const action = suggestion.action;\n\n    return typeof action?.id === 'string';\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_VALIDATE = 'retrieve';\n\nexport const VALIDATE_URL = `${SEARCH_URL}/${ENDPOINT_VALIDATE}`;\n","import { VALIDATE_URL } from './constants';\nimport { ValidateFeature } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef ValidateOptions\n */\nexport interface ValidateOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link ValidateOptions#proximity} and {@link ValidateOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef ValidateResponse\n */\nexport interface ValidateResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: ValidateFeature[];\n}\n\n/**\n * A `MapboxValidate` object is an application's main entrypoint to the\n * Mapbox Validate API. The Mapbox Validate API is an API similar to {@link MapboxAutofill},\n * but targeted at checking **address**.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxValidate`, and\n * other options may be specified either in the constructor or in the {@link MapboxValidate#validate} call.\n *\n * @class MapboxValidate\n * @param {ValidateOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxValidate {\n  static defaults: Partial<ValidateOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link ValidateOptions}) to be merged into options in the following methods:\n   * - {@link ValidateOptions#validate}\n   *\n   * @type {ValidateOptions}\n   */\n  defaults: Partial<ValidateOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & ValidateOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxValidate.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxValidate#validate} allows you to validate an address\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async validate(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<ValidateResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as ValidateResponse;\n\n    if (json.features.length > 0) {\n      json.features = [json.features[0]];\n    }\n\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxValidate#validate}\n   */\n  #getQueryParams(\n    options: Partial<ValidateOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/geocoding/v5`;\n\nexport const TEMP_URL = `${SEARCH_URL}/mapbox.places`;\nexport const PERMANENT_URL = `${SEARCH_URL}/mapbox.places-permanent`;\n","import { getFetch } from '../fetch';\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { handleNonOkRes } from '../MapboxError';\nimport { queryParams } from '../utils/queryParams';\nimport { PERMANENT_URL, TEMP_URL } from './constants';\nimport { DataTypes, GeocodeFeature } from './types';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @typedef GeocodeOptions\n */\nexport interface GeocodeOptions {\n  /**\n   * When autocomplete is enabled, results will be included that start with the requested string, rather than just responses that match it exactly.\n   *\n   * Defaults to true.\n   */\n  autocomplete: boolean;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * Limit results to one or more countries. Permitted values are [ISO 3166 alpha 2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country codes separated by commas.\n   */\n  country: string;\n  /**\n   * Specify whether the Geocoding API should attempt approximate, as well as exact, matching when performing searches.\n   *\n   * Defaults to true.\n   */\n  fuzzyMatch: boolean;\n  /**\n   * An [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) that controls the language of the text supplied in responses, and also affects result scoring.\n   */\n  language: string;\n  /**\n   * The number of results to return, up to `10`.\n   *\n   * Defaults to 5.\n   */\n  limit: number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * Provided as two comma-separated coordinates in longitude,latitude order, or the string `ip` to bias based on reverse IP lookup.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Specify whether to request additional metadata about the recommended navigation destination corresponding to the feature (`true`) or not (`false`, default). Only applicable for address features.\n   */\n  routing: boolean;\n  /**\n   * Filter results to include only a subset (one or more) of the available feature types. Multiple options can be comma-separated.\n   */\n  types: string | Set<DataTypes>;\n  /**\n   * Available worldviews are: `cn`, `in`, `jp`, `us`. If a worldview is not set, `us` worldview boundaries will be returned.\n   */\n  worldview: string;\n}\n\ninterface PermanentOptions {\n  /**\n   * Permanent geocodes are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * A `GeocodeResponse` object represents a returned data object from the [Mapbox Geocoding API](https://docs.mapbox.com/api/search/geocoding/#geocoding-response-object).\n *\n * @typedef GeocodeResponse\n */\nexport interface GeocodeResponse {\n  /**\n   * `\"FeatureCollection\"`, a GeoJSON type from the [GeoJSON specification](https://tools.ietf.org/html/rfc7946).\n   */\n  type: 'FeatureCollection';\n  /**\n   * Forward geocodes: An array of space and punctuation-separated strings from the original query.\n   *\n   * Reverse geocodes: An array containing the coordinates being queried.\n   */\n  query: string[];\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link GeocodeFeature}\n   */\n  features: GeocodeFeature[];\n  /**\n   * Attributes the results of the Mapbox Geocoding API to Mapbox.\n   */\n  attribution: string;\n}\n\n/**\n * A `MapboxGeocode` object is an application's main entrypoint to the [Mapbox Geocoding API](https://docs.mapbox.com/api/search/geocoding/).\n * The Geocoding API allows forward (location to coordinates) and reverse (coordinates to location) queries, enabled by corresponding\n * methods from the `MapboxGeocode` object.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxGeocode`, and\n * other options may be specified either in the constructor or in the {@link MapboxGeocode#forward} or {@link MapboxGeocode#reverse} calls.\n *\n * @class MapboxGeocode\n *\n * @example\n * ```typescript\n * const geocode = new MapboxGeocode({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const results = await geocode.forward('Washington D.C.');\n * if (results.features.length === 0) return;\n *\n * const feature = results.features[0];\n * doSomethingWithCoordinates(feature);\n * ```\n */\nexport class MapboxGeocode {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link GeocodeOptions}) to be merged into options in the following methods:\n   * - {@link MapboxGeocode#forward}\n   * - {@link MapboxGeocode#reverse}\n   */\n  defaults: Partial<GeocodeOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & GeocodeOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxGeocode#forward} allows you to look up a single location by name\n   * and returns the feature(s) and corresponding geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, geographic coordinates should be used ephemerally and not persisted.\n   * If the results are to be cached/stored in a customer database,\n   * calls to {@link MapboxGeocode#forward} should specify `permanent: true` within the method options argument.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {GeocodeOptions} [optionsArg]\n   * @param {AbortSignal} [optionsArg.signal]\n   *\n   * @example\n   * ```typescript\n   * const results = await geocode.forward('Washington D.C.');\n   * if (results.features.length === 0) return;\n   *\n   * const feature = results.features[0];\n   * doSomethingWithCoordinates(feature);\n   * ```\n   */\n  async forward(\n    searchText: string,\n    optionsArg?: Partial<FetchOptions & GeocodeOptions & PermanentOptions>\n  ): Promise<GeocodeResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n\n    let signal: AbortSignal;\n    if (optionsArg) {\n      ({ signal } = optionsArg);\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const fetchInit = signal ? { signal } : {};\n    const res = await fetch(url.toString(), fetchInit);\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as GeocodeResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxGeocode#reverse} allows you to look up a single pair of coordinates and returns the\n   * geographic feature or features that exist at that location in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, geographic coordinates should be used ephemerally and not persisted.\n   * If the results are to be cached/stored in a customer database,\n   * calls to {@link MapboxGeocode#reverse} should specify `permanent: true` within the method options argument.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {String} searchText\n   * @param {GeocodeOptions} [optionsArg]\n   * @param {AbortSignal} [optionsArg.signal]\n   *\n   * @example\n   * ```typescript\n   * const results = await geocode.reverse({ lat: 40.7736, lng: -73.9749 });\n   * if (results.features.length === 0) return;\n   *\n   * const feature = results.features[0];\n   * doSomethingWithFeature(feature);\n   * ```\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg?: Partial<FetchOptions & GeocodeOptions & PermanentOptions>\n  ): Promise<GeocodeResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n\n    let signal: AbortSignal;\n    if (optionsArg) {\n      ({ signal } = optionsArg);\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n    const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n    url.search = this.#getQueryParams(options, true);\n\n    const { fetch } = getFetch();\n    const fetchInit = signal ? { signal } : {};\n    const res = await fetch(url.toString(), fetchInit);\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as GeocodeResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link <MapboxGeocode>#forward} and {@link <MapboxGeocode>#reverse}\n   */\n  #getQueryParams(options: Partial<GeocodeOptions>, isReverse = false): string {\n    // Remove query parameters that don't apply to forward or reverse\n    if (isReverse) {\n      ['proximity', 'autocomplete', 'fuzzyMatch', 'bbox'].forEach((key) => {\n        if (key in options) {\n          delete options[key];\n        }\n      });\n    }\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        autocomplete: options.autocomplete,\n        fuzzyMatch: options.fuzzyMatch,\n        routing: options.routing,\n        worldview: options.worldview\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n}\n","/**\n * @typedef MatchCodeConfidence\n */\nexport const enum MatchCodeConfidence {\n  /**\n   * An exact match.\n   */\n  exact = 'exact',\n  /**\n   * High confidence of a match.\n   */\n  high = 'high',\n  /**\n   * Medium confidence of a match.\n   */\n  medium = 'medium',\n  /**\n   * Low confidence of a match.\n   */\n  low = 'low'\n}\n\n/**\n * An object describing the level of confidence that the given response feature matches the address intended by the request query.\n * Includes boolean flags denoting matches for each address sub-component.\n *\n * @typedef MatchCode\n */\nexport interface MatchCode {\n  /**\n   * A measure of confidence that the returned feature suggestion matches the intended address, based on the search text provided.\n   */\n  confidence: MatchCodeConfidence;\n  /**\n   * True if the confidence value is \"exact\".\n   */\n  exact_match: boolean;\n  /**\n   * True if the house number component was matched.\n   */\n  house_number: boolean;\n  /**\n   * True if the street component was matched.\n   */\n  street: boolean;\n  /**\n   * True if the postcode was matched.\n   */\n  postcode: boolean;\n  /**\n   * True if the place component was matched.\n   */\n  place: boolean;\n  /**\n   * True if the region component was matched.\n   */\n  region?: boolean;\n  /**\n   * True if the locality component was matched.\n   */\n  locality?: boolean;\n}\n","/**\n * `Evented` mixes methods into other classes for event capabilities.\n *\n * If you are an end-user, you will most likely use these methods through\n * classes like {@link SearchSession}.\n *\n * For lists of events you can listen for, see API documentation for\n * specific classes.\n *\n * @class Evented\n */\nexport class Evented<T> {\n  #listeners: Partial<{\n    [key in keyof T]: ((arg0: T[key]) => void)[];\n  }> = {};\n\n  /**\n   * Adds a listener to a specified event type.\n   *\n   * @param type - The event type to add a listen for.\n   * @param listener - The function to be called when the event is fired.\n   */\n  addEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // Create listener if doesn't already exist.\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   *\n   * @param type - The event type to remove listeners for.\n   * @param listener - The listener function to remove.\n   */\n  removeEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire<K extends keyof T>(type: K, arg0: T[K]): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n}\n","/**\n * Version of the classic `debounce` function that accepts a `signalFn`\n * argument, which can return an {@link AbortSignal}.\n */\nexport function debounce<F extends (...args: unknown[]) => unknown>(\n  func: F,\n  wait: number,\n  signalFn?: () => AbortSignal\n): F {\n  let timeout = null;\n\n  return ((...args: Parameters<F>) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal?.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  }) as F;\n}\n","/* eslint-disable prefer-const */\nimport { SessionToken, SessionTokenLike } from './SessionToken';\n\nimport { getFetch } from './fetch';\n\nimport { Evented } from './utils/Evented';\nimport { debounce } from './utils/debounce';\n\n/**\n * Shortcut function to create a new AbortController from the polyfill.\n */\nfunction createAbortController(): AbortController {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\n\ninterface EventTypes<SuggestionResponse, RetrieveResponse> {\n  suggest: SuggestionResponse;\n  suggesterror: Error;\n  retrieve: RetrieveResponse;\n}\n\n/**\n * TypeScript magic section: what is this?\n *\n * Despite the name {@link SearchSession}, in Search JS Web we use it to control\n * both {@link MapboxSearch} **and** {@link MapboxAutofill} instances. Both\n * of these have similar workflows, but are separate APIs with different options\n * and responses.\n *\n * In order to make TypeScript happy, this type is an \"approximation\" of what\n * {@link SearchSession} uses. When you construct a new {@link SearchSession},\n * because of this type [Options, Suggestion, SuggestionResponse, RetrieveResponse]\n * are automatically inferred.\n *\n * @internal\n * @example\n * ```typescript\n * const autofill = new MapboxAutofill({\n *  accessToken: 'pk.my-fancy-token',\n * });\n *\n * const session = new SearchSession(autofill);\n *\n * `session` has inferred type = SearchSession<\n *   AutofillOptions,\n *   AutofillSuggestion,\n *   AutofillSuggestionResponse,\n *   AutofillRetrieveResponse\n * >\n * ```\n */\ntype SuggestSearch<Options, Suggestion, SuggestionResponse, RetrieveResponse> =\n  {\n    suggest: (\n      text: string,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n        signal: AbortSignal;\n      }\n    ) => Promise<SuggestionResponse>;\n    retrieve: (\n      suggestion: Suggestion,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n      }\n    ) => Promise<RetrieveResponse>;\n    canRetrieve?: (suggestion: Suggestion) => boolean;\n    canSuggest?: (suggestion: Suggestion) => boolean;\n  };\n\n/**\n * A `SearchSession` object is a managed entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/)\n * or Mapbox Autocomplete API.\n *\n * `SearchSession` abstracts the suggest/retrieve flow of the two-step interactive search experience.\n *\n * Compared to using these APIs directly, you can use a `SearchSession` to:\n * 1. Automatically manage the session token lifecycle.\n * 2. Debounce calls to {@link SearchSession#suggest}.\n * 2. Abort in-flight requests with an imperative API.\n *\n * @class SearchSession\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n * const session = new SearchSession(search);\n *\n * session.addEventListener('suggest', (res) => {\n *   presentResultsToUser(res.suggestions);\n * });\n *\n * session.addEventListener('retrieve', (res) => {\n *   doSomethingWithFeatureCollection(res);\n * });\n *\n * document.querySelector('button').addEventListener('click', (event) => {\n *   const suggestions = session.suggestions?.suggestions;\n *   if (!suggestions || !suggestions.length) {\n *     return;\n *   }\n *\n *   const suggestion = suggestions[0];\n *   if (session.canRetrieve(suggestion)) {\n *     session.retrieve(suggestion);\n *   } else if (session.canSuggest(suggestion)) {\n *     // .. go through suggest flow again ..\n *     session.suggest(suggestion.text);\n *   }\n * });\n *\n * session.suggest('Washington D.C.');\n * ```\n * @param {MapboxSearch | MapboxAutofill} search - The search interface to wrap.\n * @param {number} wait - The time in milliseconds to wait before sending a new request to the {@link SearchSession#suggest} call.\n */\nexport class SearchSession<\n  Options,\n  Suggestion,\n  SuggestionResponse,\n  RetrieveResponse\n> extends Evented<EventTypes<SuggestionResponse, RetrieveResponse>> {\n  readonly search: SuggestSearch<\n    Options,\n    Suggestion,\n    SuggestionResponse,\n    RetrieveResponse\n  >;\n\n  /**\n   * The time in milliseconds to wait before sending a new request to the\n   * {@link SearchSession#suggest} call.\n   */\n  readonly debounce: number;\n\n  /**\n   * The session token is an SKU (billing token) used to identify the current\n   * search session and provide analytics to the customer.\n   *\n   * As per {@link SessionToken}, this is a UUIDv4 value.\n   *\n   */\n  sessionToken = new SessionToken();\n\n  #suggestions: SuggestionResponse | null;\n\n  /**\n   * The suggestions from the last successful suggest call, if any.\n   */\n  get suggestions(): SuggestionResponse | null {\n    return this.#suggestions;\n  }\n\n  constructor(\n    search: SuggestSearch<\n      Options,\n      Suggestion,\n      SuggestionResponse,\n      RetrieveResponse\n    >,\n    wait = 0\n  ) {\n    super();\n\n    // Set 'suggest' method using debounce.\n    this.#suggestDebounce = debounce(\n      async (\n        searchText: string,\n        options: Partial<Options> = {}\n      ): Promise<void> => {\n        // Refresh abort controller.\n        this.#abort.abort();\n        this.#abort = createAbortController();\n\n        if (!searchText) {\n          this.#suggestions = null;\n          this.fire('suggest', this.#suggestions);\n          return;\n        }\n\n        try {\n          const res = await this.search.suggest(searchText, {\n            sessionToken: this.sessionToken,\n            ...options,\n            signal: this.#abort.signal\n          });\n\n          this.#suggestions = res;\n          this.fire('suggest', res);\n        } catch (err) {\n          if (err.name === 'AbortError') {\n            return;\n          }\n\n          this.fire('suggesterror', err);\n        }\n      },\n      wait,\n      () => this.#abort.signal\n    );\n\n    /**\n     * Define properties using {@link Object#defineProperties} so they are readonly during runtime,\n     * not just in TypeScript.\n     */\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  /**\n   * The {@link AbortController} is used to abort the current suggest, either\n   * because of a new {@link SearchSession#suggest} call, or because\n   * of {@link SearchSession#abort}.\n   *\n   * In both of these cases, a new {@link AbortController} is created,\n   * and the old one is aborted.\n   */\n  #abort = createAbortController();\n\n  #suggestDebounce: (searchText: string, options?: Partial<Options>) => void;\n\n  /** @section {Methods} */\n\n  /**\n   * {@link SearchSession#suggest} is \"part one\" of the two-step interactive search experience,\n   * and each suggestion includes metadata to present to the user.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link SearchSession#retrieve}.\n   *\n   * It may be useful to call {@link SearchSession#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link SearchSession#canSuggest}, and further calls to {@link SearchSession#suggest}.\n   *\n   * Results can be retrieved with the \"suggest\" event.\n   *\n   * @example\n   * ```typescript\n   * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n   * const session = new SearchSession(search);\n   *\n   * session.addEventListener('suggest', (res) => {\n   *   presentResultsToUser(res.suggestions);\n   * });\n   *\n   * session.suggest('Washington D.C.');\n   * ```\n   */\n  suggest(\n    searchText: string,\n    options?: Partial<Options>\n  ): Promise<SuggestionResponse> {\n    this.#suggestDebounce(searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn: (val: SuggestionResponse) => void;\n      let suggestErrorFn: (val: Error) => void;\n\n      suggestFn = (res) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener('suggest', suggestFn);\n      this.addEventListener('suggesterror', suggestErrorFn);\n    });\n  }\n\n  /**\n   * Clears the current suggestions.\n   */\n  clear(): void {\n    this.suggest('');\n  }\n\n  /**\n   * {@link SearchSession#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link SearchSession#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, results should not be stored in a customer database.\n   * Results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    options?: Partial<Options>\n  ): Promise<RetrieveResponse> {\n    const res = await this.search.retrieve(suggestion, {\n      sessionToken: this.sessionToken,\n      ...options\n    });\n\n    this.fire('retrieve', res);\n    return res;\n  }\n\n  /**\n   * Returns true if {@link SearchSession#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  /**\n   * Returns true if {@link SearchSession#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  /**\n   * Aborts the current {@link SearchSession#suggest} request.\n   */\n  abort(): void {\n    this.#abort.abort();\n    this.#abort = createAbortController();\n  }\n}\n","import { FeatureSuggestion, Suggestion } from './search/types';\nimport {\n  AutofillFeatureSuggestion,\n  AutofillSuggestion\n} from './autofill/types';\n\nfunction featureToSuggestion(feature: FeatureSuggestion): Suggestion;\n\nfunction featureToSuggestion(\n  feature: AutofillFeatureSuggestion\n): AutofillSuggestion;\n\n/**\n * Utility function to convert the {@link FeatureSuggestion} properties to a\n * {@link Suggestion} object.\n */\nfunction featureToSuggestion(\n  feature: FeatureSuggestion | AutofillFeatureSuggestion\n): Suggestion | Omit<AutofillSuggestion, 'original_search_text' | 'action'> {\n  const { properties } = feature;\n  return {\n    ...properties\n  };\n}\n\nexport { featureToSuggestion };\n"]},"metadata":{},"sourceType":"module"}